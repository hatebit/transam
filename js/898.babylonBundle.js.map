{"version":3,"file":"js/898.babylonBundle.js","mappings":"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","sources":["webpack://trans-america/../lts/core/generated/Cameras/camera.ts","webpack://trans-america/../lts/core/generated/Events/keyboardEvents.ts","webpack://trans-america/../lts/core/generated/Events/pointerEvents.ts","webpack://trans-america/../lts/core/generated/node.ts"],"sourcesContent":["import { serialize, SerializationHelper, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Quaternion } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Frustum } from \"../Maths/math.frustum\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\ndeclare type PostProcess = import(\"../PostProcesses/postProcess\").PostProcess;\r\ndeclare type RenderTargetTexture = import(\"../Materials/Textures/renderTargetTexture\").RenderTargetTexture;\r\ndeclare type FreeCamera = import(\"./freeCamera\").FreeCamera;\r\ndeclare type TargetCamera = import(\"./targetCamera\").TargetCamera;\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\n\r\n/**\r\n * This is the base class of all the camera used in the application.\r\n * @see https://doc.babylonjs.com/features/cameras\r\n */\r\nexport class Camera extends Node {\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateDefaultParsedCamera = (name: string, scene: Scene): Camera => {\r\n        throw _WarnImport(\"UniversalCamera\");\r\n    };\r\n\r\n    /**\r\n     * This is the default projection mode used by the cameras.\r\n     * It helps recreating a feeling of perspective and better appreciate depth.\r\n     * This is the best way to simulate real life cameras.\r\n     */\r\n    public static readonly PERSPECTIVE_CAMERA = Constants.PERSPECTIVE_CAMERA;\r\n    /**\r\n     * This helps creating camera with an orthographic mode.\r\n     * Orthographic is commonly used in engineering as a means to produce object specifications that communicate dimensions unambiguously, each line of 1 unit length (cm, meter..whatever) will appear to have the same length everywhere on the drawing. This allows the drafter to dimension only a subset of lines and let the reader know that other lines of that length on the drawing are also that length in reality. Every parallel line in the drawing is also parallel in the object.\r\n     */\r\n    public static readonly ORTHOGRAPHIC_CAMERA = Constants.ORTHOGRAPHIC_CAMERA;\r\n\r\n    /**\r\n     * This is the default FOV mode for perspective cameras.\r\n     * This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.\r\n     */\r\n    public static readonly FOVMODE_VERTICAL_FIXED = Constants.FOVMODE_VERTICAL_FIXED;\r\n    /**\r\n     * This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.\r\n     */\r\n    public static readonly FOVMODE_HORIZONTAL_FIXED = Constants.FOVMODE_HORIZONTAL_FIXED;\r\n\r\n    /**\r\n     * This specifies there is no need for a camera rig.\r\n     * Basically only one eye is rendered corresponding to the camera.\r\n     */\r\n    public static readonly RIG_MODE_NONE = Constants.RIG_MODE_NONE;\r\n    /**\r\n     * Simulates a camera Rig with one blue eye and one red eye.\r\n     * This can be use with 3d blue and red glasses.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_ANAGLYPH = Constants.RIG_MODE_STEREOSCOPIC_ANAGLYPH;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered side by side with a parallel target.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered side by side with a none parallel target.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered over under each other.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_OVERUNDER = Constants.RIG_MODE_STEREOSCOPIC_OVERUNDER;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered on successive lines interlaced for passive 3d monitors.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_INTERLACED = Constants.RIG_MODE_STEREOSCOPIC_INTERLACED;\r\n    /**\r\n     * Defines that both eyes of the camera should be renderered in a VR mode (carbox).\r\n     */\r\n    public static readonly RIG_MODE_VR = Constants.RIG_MODE_VR;\r\n    /**\r\n     * Defines that both eyes of the camera should be renderered in a VR mode (webVR).\r\n     */\r\n    public static readonly RIG_MODE_WEBVR = Constants.RIG_MODE_WEBVR;\r\n    /**\r\n     * Custom rig mode allowing rig cameras to be populated manually with any number of cameras\r\n     */\r\n    public static readonly RIG_MODE_CUSTOM = Constants.RIG_MODE_CUSTOM;\r\n\r\n    /**\r\n     * Defines if by default attaching controls should prevent the default javascript event to continue.\r\n     */\r\n    public static ForceAttachControlToAlwaysPreventDefault = false;\r\n\r\n    /**\r\n     * Define the input manager associated with the camera.\r\n     */\r\n    public inputs: CameraInputsManager<Camera>;\r\n\r\n    /** @internal */\r\n    @serializeAsVector3(\"position\")\r\n    public _position = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current local position of the camera in the scene\r\n     */\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._position = newPosition;\r\n    }\r\n\r\n    @serializeAsVector3(\"upVector\")\r\n    protected _upVector = Vector3.Up();\r\n\r\n    /**\r\n     * The vector the camera should consider as up.\r\n     * (default is Vector3(0, 1, 0) aka Vector3.Up())\r\n     */\r\n    public set upVector(vec: Vector3) {\r\n        this._upVector = vec;\r\n    }\r\n\r\n    public get upVector() {\r\n        return this._upVector;\r\n    }\r\n\r\n    /**\r\n     * The screen area in scene units squared\r\n     */\r\n    public get screenArea(): number {\r\n        let x = 0;\r\n        let y = 0;\r\n        if (this.mode === Camera.PERSPECTIVE_CAMERA) {\r\n            if (this.fovMode === Camera.FOVMODE_VERTICAL_FIXED) {\r\n                y = this.minZ * 2 * Math.tan(this.fov / 2);\r\n                x = this.getEngine().getAspectRatio(this) * y;\r\n            } else {\r\n                x = this.minZ * 2 * Math.tan(this.fov / 2);\r\n                y = x / this.getEngine().getAspectRatio(this);\r\n            }\r\n        } else {\r\n            const halfWidth = this.getEngine().getRenderWidth() / 2.0;\r\n            const halfHeight = this.getEngine().getRenderHeight() / 2.0;\r\n\r\n            x = (this.orthoRight ?? halfWidth) - (this.orthoLeft ?? -halfWidth);\r\n            y = (this.orthoTop ?? halfHeight) - (this.orthoBottom ?? -halfHeight);\r\n        }\r\n\r\n        return x * y;\r\n    }\r\n\r\n    /**\r\n     * Define the current limit on the left side for an orthographic camera\r\n     * In scene unit\r\n     */\r\n    private _orthoLeft: Nullable<number> = null;\r\n\r\n    public set orthoLeft(value: Nullable<number>) {\r\n        this._orthoLeft = value;\r\n\r\n        for (const rigCamera of this._rigCameras) {\r\n            rigCamera.orthoLeft = value;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get orthoLeft(): Nullable<number> {\r\n        return this._orthoLeft;\r\n    }\r\n\r\n    /**\r\n     * Define the current limit on the right side for an orthographic camera\r\n     * In scene unit\r\n     */\r\n    private _orthoRight: Nullable<number> = null;\r\n\r\n    public set orthoRight(value: Nullable<number>) {\r\n        this._orthoRight = value;\r\n\r\n        for (const rigCamera of this._rigCameras) {\r\n            rigCamera.orthoRight = value;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get orthoRight(): Nullable<number> {\r\n        return this._orthoRight;\r\n    }\r\n\r\n    /**\r\n     * Define the current limit on the bottom side for an orthographic camera\r\n     * In scene unit\r\n     */\r\n    private _orthoBottom: Nullable<number> = null;\r\n\r\n    public set orthoBottom(value: Nullable<number>) {\r\n        this._orthoBottom = value;\r\n\r\n        for (const rigCamera of this._rigCameras) {\r\n            rigCamera.orthoBottom = value;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get orthoBottom(): Nullable<number> {\r\n        return this._orthoBottom;\r\n    }\r\n\r\n    /**\r\n     * Define the current limit on the top side for an orthographic camera\r\n     * In scene unit\r\n     */\r\n    private _orthoTop: Nullable<number> = null;\r\n\r\n    public set orthoTop(value: Nullable<number>) {\r\n        this._orthoTop = value;\r\n\r\n        for (const rigCamera of this._rigCameras) {\r\n            rigCamera.orthoTop = value;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get orthoTop(): Nullable<number> {\r\n        return this._orthoTop;\r\n    }\r\n\r\n    /**\r\n     * Field Of View is set in Radians. (default is 0.8)\r\n     */\r\n    @serialize()\r\n    public fov = 0.8;\r\n\r\n    /**\r\n     * Projection plane tilt around the X axis (horizontal), set in Radians. (default is 0)\r\n     * Can be used to make vertical lines in world space actually vertical on the screen.\r\n     * See https://forum.babylonjs.com/t/add-vertical-shift-to-3ds-max-exporter-babylon-cameras/17480\r\n     */\r\n    @serialize()\r\n    public projectionPlaneTilt = 0;\r\n\r\n    /**\r\n     * Define the minimum distance the camera can see from.\r\n     * This is important to note that the depth buffer are not infinite and the closer it starts\r\n     * the more your scene might encounter depth fighting issue.\r\n     */\r\n    @serialize()\r\n    public minZ = 1;\r\n\r\n    /**\r\n     * Define the maximum distance the camera can see to.\r\n     * This is important to note that the depth buffer are not infinite and the further it end\r\n     * the more your scene might encounter depth fighting issue.\r\n     */\r\n    @serialize()\r\n    public maxZ = 10000.0;\r\n\r\n    /**\r\n     * Define the default inertia of the camera.\r\n     * This helps giving a smooth feeling to the camera movement.\r\n     */\r\n    @serialize()\r\n    public inertia = 0.9;\r\n\r\n    /**\r\n     * Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.ORTHOGRAPHIC_CAMERA)\r\n     */\r\n    private _mode = Camera.PERSPECTIVE_CAMERA;\r\n    set mode(mode: number) {\r\n        this._mode = mode;\r\n\r\n        // Pass the mode down to the rig cameras\r\n        for (const rigCamera of this._rigCameras) {\r\n            rigCamera.mode = mode;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Define whether the camera is intermediate.\r\n     * This is useful to not present the output directly to the screen in case of rig without post process for instance\r\n     */\r\n    public isIntermediate = false;\r\n\r\n    /**\r\n     * Define the viewport of the camera.\r\n     * This correspond to the portion of the screen the camera will render to in normalized 0 to 1 unit.\r\n     */\r\n    public viewport = new Viewport(0, 0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Restricts the camera to viewing objects with the same layerMask.\r\n     * A camera with a layerMask of 1 will render mesh.layerMask & camera.layerMask!== 0\r\n     */\r\n    @serialize()\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * fovMode sets the camera frustum bounds to the viewport bounds. (default is FOVMODE_VERTICAL_FIXED)\r\n     */\r\n    @serialize()\r\n    public fovMode: number = Camera.FOVMODE_VERTICAL_FIXED;\r\n\r\n    /**\r\n     * Rig mode of the camera.\r\n     * This is useful to create the camera with two \"eyes\" instead of one to create VR or stereoscopic scenes.\r\n     * This is normally controlled byt the camera themselves as internal use.\r\n     */\r\n    @serialize()\r\n    public cameraRigMode = Camera.RIG_MODE_NONE;\r\n\r\n    /**\r\n     * Defines the distance between both \"eyes\" in case of a RIG\r\n     */\r\n    @serialize()\r\n    public interaxialDistance: number;\r\n\r\n    /**\r\n     * Defines if stereoscopic rendering is done side by side or over under.\r\n     */\r\n    @serialize()\r\n    public isStereoscopicSideBySide: boolean;\r\n\r\n    /**\r\n     * Defines the list of custom render target which are rendered to and then used as the input to this camera's render. Eg. display another camera view on a TV in the main scene\r\n     * This is pretty helpful if you wish to make a camera render to a texture you could reuse somewhere\r\n     * else in the scene. (Eg. security camera)\r\n     *\r\n     * To change the final output target of the camera, camera.outputRenderTarget should be used instead (eg. webXR renders to a render target corresponding to an HMD)\r\n     */\r\n    public customRenderTargets = new Array<RenderTargetTexture>();\r\n    /**\r\n     * When set, the camera will render to this render target instead of the default canvas\r\n     *\r\n     * If the desire is to use the output of a camera as a texture in the scene consider using camera.customRenderTargets instead\r\n     */\r\n    public outputRenderTarget: Nullable<RenderTargetTexture> = null;\r\n\r\n    /**\r\n     * Observable triggered when the camera view matrix has changed.\r\n     */\r\n    public onViewMatrixChangedObservable = new Observable<Camera>();\r\n    /**\r\n     * Observable triggered when the camera Projection matrix has changed.\r\n     */\r\n    public onProjectionMatrixChangedObservable = new Observable<Camera>();\r\n    /**\r\n     * Observable triggered when the inputs have been processed.\r\n     */\r\n    public onAfterCheckInputsObservable = new Observable<Camera>();\r\n    /**\r\n     * Observable triggered when reset has been called and applied to the camera.\r\n     */\r\n    public onRestoreStateObservable = new Observable<Camera>();\r\n\r\n    /**\r\n     * Is this camera a part of a rig system?\r\n     */\r\n    public isRigCamera: boolean = false;\r\n\r\n    /**\r\n     * If isRigCamera set to true this will be set with the parent camera.\r\n     * The parent camera is not (!) necessarily the .parent of this camera (like in the case of XR)\r\n     */\r\n    public rigParent?: Camera;\r\n\r\n    /**\r\n     * Render pass id used by the camera to render into the main framebuffer\r\n     */\r\n    public renderPassId: number;\r\n\r\n    /** @internal */\r\n    public _cameraRigParams: any;\r\n    /** @internal */\r\n    public _rigCameras = new Array<Camera>();\r\n    /** @internal */\r\n    public _rigPostProcess: Nullable<PostProcess>;\r\n\r\n    protected _webvrViewMatrix = Matrix.Identity();\r\n    /** @internal */\r\n    public _skipRendering = false;\r\n\r\n    /** @internal */\r\n    public _projectionMatrix = new Matrix();\r\n\r\n    /** @internal */\r\n    public _postProcesses = new Array<Nullable<PostProcess>>();\r\n\r\n    /** @internal */\r\n    public _activeMeshes = new SmartArray<AbstractMesh>(256);\r\n\r\n    protected _globalPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _computedViewMatrix = Matrix.Identity();\r\n    private _doNotComputeProjectionMatrix = false;\r\n    private _transformMatrix = Matrix.Zero();\r\n    private _frustumPlanes: Plane[];\r\n    private _refreshFrustumPlanes = true;\r\n    private _storedFov: number;\r\n    private _stateStored: boolean;\r\n    private _absoluteRotation: Quaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * Instantiates a new camera object.\r\n     * This should not be used directly but through the inherited cameras: ArcRotate, Free...\r\n     * @see https://doc.babylonjs.com/features/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the position of the camera\r\n     * @param scene Defines the scene the camera belongs too\r\n     * @param setActiveOnSceneIfNoneActive Defines if the camera should be set as active after creation if no other camera have been defined in the scene\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, scene);\r\n\r\n        this.getScene().addCamera(this);\r\n\r\n        if (setActiveOnSceneIfNoneActive && !this.getScene().activeCamera) {\r\n            this.getScene().activeCamera = this;\r\n        }\r\n\r\n        this.position = position;\r\n        this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${name}`);\r\n    }\r\n\r\n    /**\r\n     * Store current camera state (fov, position, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._stateStored = true;\r\n        this._storedFov = this.fov;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Restores the camera state values if it has been stored. You must call storeState() first\r\n     */\r\n    protected _restoreStateValues(): boolean {\r\n        if (!this._stateStored) {\r\n            return false;\r\n        }\r\n\r\n        this.fov = this._storedFov;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first.\r\n     * @returns true if restored and false otherwise\r\n     */\r\n    public restoreState(): boolean {\r\n        if (this._restoreStateValues()) {\r\n            this.onRestoreStateObservable.notifyObservers(this);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the camera.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Camera\";\r\n    }\r\n\r\n    /** @internal */\r\n    public readonly _isCamera = true;\r\n\r\n    /**\r\n     * Gets a string representation of the camera useful for debug purpose.\r\n     * @param fullDetails Defines that a more verbose level of logging is required\r\n     * @returns the string representation\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + this.getClassName();\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Automatically tilts the projection plane, using `projectionPlaneTilt`, to correct the perspective effect on vertical lines.\r\n     */\r\n    public applyVerticalCorrection() {\r\n        const rot = this.absoluteRotation.toEulerAngles();\r\n\r\n        this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;\r\n    }\r\n\r\n    /**\r\n     * Gets the current world space position of the camera.\r\n     */\r\n    public get globalPosition(): Vector3 {\r\n        return this._globalPosition;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)\r\n     * @returns the active meshe list\r\n     */\r\n    public getActiveMeshes(): SmartArray<AbstractMesh> {\r\n        return this._activeMeshes;\r\n    }\r\n\r\n    /**\r\n     * Check whether a mesh is part of the current active mesh list of the camera\r\n     * @param mesh Defines the mesh to check\r\n     * @returns true if active, false otherwise\r\n     */\r\n    public isActiveMesh(mesh: Mesh): boolean {\r\n        return this._activeMeshes.indexOf(mesh) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Is this camera ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including post processes) has to be done (false by default)\r\n     * @returns true if the camera is ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        if (completeCheck) {\r\n            for (const pp of this._postProcesses) {\r\n                if (pp && !pp.isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return super.isReady(completeCheck);\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n\r\n        this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n\r\n        this._cache.mode = undefined;\r\n        this._cache.minZ = undefined;\r\n        this._cache.maxZ = undefined;\r\n\r\n        this._cache.fov = undefined;\r\n        this._cache.fovMode = undefined;\r\n        this._cache.aspectRatio = undefined;\r\n\r\n        this._cache.orthoLeft = undefined;\r\n        this._cache.orthoRight = undefined;\r\n        this._cache.orthoBottom = undefined;\r\n        this._cache.orthoTop = undefined;\r\n        this._cache.renderWidth = undefined;\r\n        this._cache.renderHeight = undefined;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        this._cache.position.copyFrom(this.position);\r\n        this._cache.upVector.copyFrom(this.upVector);\r\n    }\r\n\r\n    /** @internal */\r\n    public _isSynchronized(): boolean {\r\n        return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronized()) {\r\n            return false;\r\n        }\r\n\r\n        return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isSynchronizedProjectionMatrix(): boolean {\r\n        let check = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;\r\n\r\n        if (!check) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this.getEngine();\r\n\r\n        if (this.mode === Camera.PERSPECTIVE_CAMERA) {\r\n            check =\r\n                this._cache.fov === this.fov &&\r\n                this._cache.fovMode === this.fovMode &&\r\n                this._cache.aspectRatio === engine.getAspectRatio(this) &&\r\n                this._cache.projectionPlaneTilt === this.projectionPlaneTilt;\r\n        } else {\r\n            check =\r\n                this._cache.orthoLeft === this.orthoLeft &&\r\n                this._cache.orthoRight === this.orthoRight &&\r\n                this._cache.orthoBottom === this.orthoBottom &&\r\n                this._cache.orthoTop === this.orthoTop &&\r\n                this._cache.renderWidth === engine.getRenderWidth() &&\r\n                this._cache.renderHeight === engine.getRenderHeight();\r\n        }\r\n\r\n        return check;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * This function is here because typescript removes the typing of the last function.\r\n     * @param _ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param _noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(_ignored?: any, _noPreventDefault?: boolean): void {}\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     */\r\n    public detachControl(ignored?: any): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * This function is here because typescript removes the typing of the last function.\r\n     * @param _ignored defines an ignored parameter kept for backward compatibility.\r\n     */\r\n    public detachControl(_ignored?: any): void {}\r\n\r\n    /**\r\n     * Update the camera state according to the different inputs gathered during the frame.\r\n     */\r\n    public update(): void {\r\n        this._checkInputs();\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            this._updateRigCameras();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        this.onAfterCheckInputsObservable.notifyObservers(this);\r\n    }\r\n\r\n    /** @internal */\r\n    public get rigCameras(): Camera[] {\r\n        return this._rigCameras;\r\n    }\r\n\r\n    /**\r\n     * Gets the post process used by the rig cameras\r\n     */\r\n    public get rigPostProcess(): Nullable<PostProcess> {\r\n        return this._rigPostProcess;\r\n    }\r\n\r\n    /**\r\n     * Internal, gets the first post process.\r\n     * @returns the first post process to be run on this camera.\r\n     */\r\n    public _getFirstPostProcess(): Nullable<PostProcess> {\r\n        for (let ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {\r\n            if (this._postProcesses[ppIndex] !== null) {\r\n                return this._postProcesses[ppIndex];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private _cascadePostProcessesToRigCams(): void {\r\n        // invalidate framebuffer\r\n        const firstPostProcess = this._getFirstPostProcess();\r\n        if (firstPostProcess) {\r\n            firstPostProcess.markTextureDirty();\r\n        }\r\n\r\n        // glue the rigPostProcess to the end of the user postprocesses & assign to each sub-camera\r\n        for (let i = 0, len = this._rigCameras.length; i < len; i++) {\r\n            const cam = this._rigCameras[i];\r\n            const rigPostProcess = cam._rigPostProcess;\r\n\r\n            // for VR rig, there does not have to be a post process\r\n            if (rigPostProcess) {\r\n                const isPass = rigPostProcess.getEffectName() === \"pass\";\r\n                if (isPass) {\r\n                    // any rig which has a PassPostProcess for rig[0], cannot be isIntermediate when there are also user postProcesses\r\n                    cam.isIntermediate = this._postProcesses.length === 0;\r\n                }\r\n                cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);\r\n                rigPostProcess.markTextureDirty();\r\n            } else {\r\n                cam._postProcesses = this._postProcesses.slice(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach a post process to the camera.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#attach-postprocess\r\n     * @param postProcess The post process to attach to the camera\r\n     * @param insertAt The position of the post process in case several of them are in use in the scene\r\n     * @returns the position the post process has been inserted at\r\n     */\r\n    public attachPostProcess(postProcess: PostProcess, insertAt: Nullable<number> = null): number {\r\n        if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {\r\n            Logger.Error(\"You're trying to reuse a post process not defined as reusable.\");\r\n            return 0;\r\n        }\r\n\r\n        if (insertAt == null || insertAt < 0) {\r\n            this._postProcesses.push(postProcess);\r\n        } else if (this._postProcesses[insertAt] === null) {\r\n            this._postProcesses[insertAt] = postProcess;\r\n        } else {\r\n            this._postProcesses.splice(insertAt, 0, postProcess);\r\n        }\r\n        this._cascadePostProcessesToRigCams(); // also ensures framebuffer invalidated\r\n\r\n        // Update prePass\r\n        if (this._scene.prePassRenderer) {\r\n            this._scene.prePassRenderer.markAsDirty();\r\n        }\r\n\r\n        return this._postProcesses.indexOf(postProcess);\r\n    }\r\n\r\n    /**\r\n     * Detach a post process to the camera.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#attach-postprocess\r\n     * @param postProcess The post process to detach from the camera\r\n     */\r\n    public detachPostProcess(postProcess: PostProcess): void {\r\n        const idx = this._postProcesses.indexOf(postProcess);\r\n        if (idx !== -1) {\r\n            this._postProcesses[idx] = null;\r\n        }\r\n\r\n        // Update prePass\r\n        if (this._scene.prePassRenderer) {\r\n            this._scene.prePassRenderer.markAsDirty();\r\n        }\r\n\r\n        this._cascadePostProcessesToRigCams(); // also ensures framebuffer invalidated\r\n    }\r\n\r\n    /**\r\n     * Gets the current world matrix of the camera\r\n     */\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._isSynchronizedViewMatrix()) {\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        // Getting the the view matrix will also compute the world matrix.\r\n        this.getViewMatrix();\r\n\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        return Matrix.Identity();\r\n    }\r\n\r\n    /**\r\n     * Gets the current view matrix of the camera.\r\n     * @param force forces the camera to recompute the matrix without looking at the cached state\r\n     * @returns the view matrix\r\n     */\r\n    public getViewMatrix(force?: boolean): Matrix {\r\n        if (!force && this._isSynchronizedViewMatrix()) {\r\n            return this._computedViewMatrix;\r\n        }\r\n\r\n        this.updateCache();\r\n        this._computedViewMatrix = this._getViewMatrix();\r\n        this._currentRenderId = this.getScene().getRenderId();\r\n        this._childUpdateId++;\r\n\r\n        this._refreshFrustumPlanes = true;\r\n\r\n        if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {\r\n            this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);\r\n        }\r\n\r\n        // Notify parent camera if rig camera is changed\r\n        if (this.parent && (this.parent as Camera).onViewMatrixChangedObservable) {\r\n            (this.parent as Camera).onViewMatrixChangedObservable.notifyObservers(this.parent as Camera);\r\n        }\r\n\r\n        this.onViewMatrixChangedObservable.notifyObservers(this);\r\n\r\n        this._computedViewMatrix.invertToRef(this._worldMatrix);\r\n\r\n        return this._computedViewMatrix;\r\n    }\r\n\r\n    /**\r\n     * Freeze the projection matrix.\r\n     * It will prevent the cache check of the camera projection compute and can speed up perf\r\n     * if no parameter of the camera are meant to change\r\n     * @param projection Defines manually a projection if necessary\r\n     */\r\n    public freezeProjectionMatrix(projection?: Matrix): void {\r\n        this._doNotComputeProjectionMatrix = true;\r\n        if (projection !== undefined) {\r\n            this._projectionMatrix = projection;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.\r\n     */\r\n    public unfreezeProjectionMatrix(): void {\r\n        this._doNotComputeProjectionMatrix = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current projection matrix of the camera.\r\n     * @param force forces the camera to recompute the matrix without looking at the cached state\r\n     * @returns the projection matrix\r\n     */\r\n    public getProjectionMatrix(force?: boolean): Matrix {\r\n        if (this._doNotComputeProjectionMatrix || (!force && this._isSynchronizedProjectionMatrix())) {\r\n            return this._projectionMatrix;\r\n        }\r\n\r\n        // Cache\r\n        this._cache.mode = this.mode;\r\n        this._cache.minZ = this.minZ;\r\n        this._cache.maxZ = this.maxZ;\r\n\r\n        // Matrix\r\n        this._refreshFrustumPlanes = true;\r\n\r\n        const engine = this.getEngine();\r\n        const scene = this.getScene();\r\n        const reverseDepth = engine.useReverseDepthBuffer;\r\n        if (this.mode === Camera.PERSPECTIVE_CAMERA) {\r\n            this._cache.fov = this.fov;\r\n            this._cache.fovMode = this.fovMode;\r\n            this._cache.aspectRatio = engine.getAspectRatio(this);\r\n            this._cache.projectionPlaneTilt = this.projectionPlaneTilt;\r\n\r\n            if (this.minZ <= 0) {\r\n                this.minZ = 0.1;\r\n            }\r\n\r\n            let getProjectionMatrix: (\r\n                fov: number,\r\n                aspect: number,\r\n                znear: number,\r\n                zfar: number,\r\n                result: Matrix,\r\n                isVerticalFovFixed: boolean,\r\n                halfZRange: boolean,\r\n                projectionPlaneTilt: number,\r\n                reverseDepthBufferMode: boolean\r\n            ) => void;\r\n            if (scene.useRightHandedSystem) {\r\n                getProjectionMatrix = Matrix.PerspectiveFovRHToRef;\r\n            } else {\r\n                getProjectionMatrix = Matrix.PerspectiveFovLHToRef;\r\n            }\r\n\r\n            getProjectionMatrix(\r\n                this.fov,\r\n                engine.getAspectRatio(this),\r\n                reverseDepth ? this.maxZ : this.minZ,\r\n                reverseDepth ? this.minZ : this.maxZ,\r\n                this._projectionMatrix,\r\n                this.fovMode === Camera.FOVMODE_VERTICAL_FIXED,\r\n                engine.isNDCHalfZRange,\r\n                this.projectionPlaneTilt,\r\n                reverseDepth\r\n            );\r\n        } else {\r\n            const halfWidth = engine.getRenderWidth() / 2.0;\r\n            const halfHeight = engine.getRenderHeight() / 2.0;\r\n            if (scene.useRightHandedSystem) {\r\n                Matrix.OrthoOffCenterRHToRef(\r\n                    this.orthoLeft ?? -halfWidth,\r\n                    this.orthoRight ?? halfWidth,\r\n                    this.orthoBottom ?? -halfHeight,\r\n                    this.orthoTop ?? halfHeight,\r\n                    reverseDepth ? this.maxZ : this.minZ,\r\n                    reverseDepth ? this.minZ : this.maxZ,\r\n                    this._projectionMatrix,\r\n                    engine.isNDCHalfZRange\r\n                );\r\n            } else {\r\n                Matrix.OrthoOffCenterLHToRef(\r\n                    this.orthoLeft ?? -halfWidth,\r\n                    this.orthoRight ?? halfWidth,\r\n                    this.orthoBottom ?? -halfHeight,\r\n                    this.orthoTop ?? halfHeight,\r\n                    reverseDepth ? this.maxZ : this.minZ,\r\n                    reverseDepth ? this.minZ : this.maxZ,\r\n                    this._projectionMatrix,\r\n                    engine.isNDCHalfZRange\r\n                );\r\n            }\r\n\r\n            this._cache.orthoLeft = this.orthoLeft;\r\n            this._cache.orthoRight = this.orthoRight;\r\n            this._cache.orthoBottom = this.orthoBottom;\r\n            this._cache.orthoTop = this.orthoTop;\r\n            this._cache.renderWidth = engine.getRenderWidth();\r\n            this._cache.renderHeight = engine.getRenderHeight();\r\n        }\r\n\r\n        this.onProjectionMatrixChangedObservable.notifyObservers(this);\r\n\r\n        return this._projectionMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the transformation matrix (ie. the multiplication of view by projection matrices)\r\n     * @returns a Matrix\r\n     */\r\n    public getTransformationMatrix(): Matrix {\r\n        this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\r\n        return this._transformMatrix;\r\n    }\r\n\r\n    private _updateFrustumPlanes(): void {\r\n        if (!this._refreshFrustumPlanes) {\r\n            return;\r\n        }\r\n\r\n        this.getTransformationMatrix();\r\n\r\n        if (!this._frustumPlanes) {\r\n            this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\r\n        } else {\r\n            Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\r\n        }\r\n\r\n        this._refreshFrustumPlanes = false;\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * This checks the bounding box center. See isCompletelyInFrustum for a full bounding check\r\n     * @param target The object to check\r\n     * @param checkRigCameras If the rig cameras should be checked (eg. with webVR camera both eyes should be checked) (Default: false)\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isInFrustum(target: ICullable, checkRigCameras = false): boolean {\r\n        this._updateFrustumPlanes();\r\n\r\n        if (checkRigCameras && this.rigCameras.length > 0) {\r\n            let result = false;\r\n            this.rigCameras.forEach((cam) => {\r\n                cam._updateFrustumPlanes();\r\n                result = result || target.isInFrustum(cam._frustumPlanes);\r\n            });\r\n            return result;\r\n        } else {\r\n            return target.isInFrustum(this._frustumPlanes);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param target The object to check\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isCompletelyInFrustum(target: ICullable): boolean {\r\n        this._updateFrustumPlanes();\r\n\r\n        return target.isCompletelyInFrustum(this._frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Gets a ray in the forward direction from the camera.\r\n     * @param length Defines the length of the ray to create\r\n     * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a workd space ray\r\n     * @param origin Defines the start point of the ray which defaults to the camera position\r\n     * @returns the forward ray\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getForwardRay(length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n        throw _WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Gets a ray in the forward direction from the camera.\r\n     * @param refRay the ray to (re)use when setting the values\r\n     * @param length Defines the length of the ray to create\r\n     * @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray\r\n     * @param origin Defines the start point of the ray which defaults to the camera position\r\n     * @returns the forward ray\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getForwardRayToRef(refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n        throw _WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Observables\r\n        this.onViewMatrixChangedObservable.clear();\r\n        this.onProjectionMatrixChangedObservable.clear();\r\n        this.onAfterCheckInputsObservable.clear();\r\n        this.onRestoreStateObservable.clear();\r\n\r\n        // Inputs\r\n        if (this.inputs) {\r\n            this.inputs.clear();\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeCamera(this);\r\n        while (this._rigCameras.length > 0) {\r\n            const camera = this._rigCameras.pop();\r\n            if (camera) {\r\n                camera.dispose();\r\n            }\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.cameras.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.cameras.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        // Postprocesses\r\n        if (this._rigPostProcess) {\r\n            this._rigPostProcess.dispose(this);\r\n            this._rigPostProcess = null;\r\n            this._postProcesses.length = 0;\r\n        } else if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            this._rigPostProcess = null;\r\n            this._postProcesses.length = 0;\r\n        } else {\r\n            let i = this._postProcesses.length;\r\n            while (--i >= 0) {\r\n                const postProcess = this._postProcesses[i];\r\n                if (postProcess) {\r\n                    postProcess.dispose(this);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Render targets\r\n        let i = this.customRenderTargets.length;\r\n        while (--i >= 0) {\r\n            this.customRenderTargets[i].dispose();\r\n        }\r\n        this.customRenderTargets.length = 0;\r\n\r\n        // Active Meshes\r\n        this._activeMeshes.dispose();\r\n\r\n        this.getScene().getEngine().releaseRenderPassId(this.renderPassId);\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /** @internal */\r\n    public _isLeftCamera = false;\r\n    /**\r\n     * Gets the left camera of a rig setup in case of Rigged Camera\r\n     */\r\n    public get isLeftCamera(): boolean {\r\n        return this._isLeftCamera;\r\n    }\r\n\r\n    /** @internal */\r\n    public _isRightCamera = false;\r\n    /**\r\n     * Gets the right camera of a rig setup in case of Rigged Camera\r\n     */\r\n    public get isRightCamera(): boolean {\r\n        return this._isRightCamera;\r\n    }\r\n\r\n    /**\r\n     * Gets the left camera of a rig setup in case of Rigged Camera\r\n     */\r\n    public get leftCamera(): Nullable<FreeCamera> {\r\n        if (this._rigCameras.length < 1) {\r\n            return null;\r\n        }\r\n        return <FreeCamera>this._rigCameras[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right camera of a rig setup in case of Rigged Camera\r\n     */\r\n    public get rightCamera(): Nullable<FreeCamera> {\r\n        if (this._rigCameras.length < 2) {\r\n            return null;\r\n        }\r\n        return <FreeCamera>this._rigCameras[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the left camera target of a rig setup in case of Rigged Camera\r\n     * @returns the target position\r\n     */\r\n    public getLeftTarget(): Nullable<Vector3> {\r\n        if (this._rigCameras.length < 1) {\r\n            return null;\r\n        }\r\n        return (<TargetCamera>this._rigCameras[0]).getTarget();\r\n    }\r\n\r\n    /**\r\n     * Gets the right camera target of a rig setup in case of Rigged Camera\r\n     * @returns the target position\r\n     */\r\n    public getRightTarget(): Nullable<Vector3> {\r\n        if (this._rigCameras.length < 2) {\r\n            return null;\r\n        }\r\n        return (<TargetCamera>this._rigCameras[1]).getTarget();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setCameraRigMode(mode: number, rigParams: any): void {\r\n        if (this.cameraRigMode === mode) {\r\n            return;\r\n        }\r\n\r\n        while (this._rigCameras.length > 0) {\r\n            const camera = this._rigCameras.pop();\r\n\r\n            if (camera) {\r\n                camera.dispose();\r\n            }\r\n        }\r\n        this.cameraRigMode = mode;\r\n        this._cameraRigParams = {};\r\n        //we have to implement stereo camera calcultating left and right viewpoints from interaxialDistance and target,\r\n        //not from a given angle as it is now, but until that complete code rewriting provisional stereoHalfAngle value is introduced\r\n        this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;\r\n        this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);\r\n\r\n        // create the rig cameras, unless none\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const leftCamera = this.createRigCamera(this.name + \"_L\", 0);\r\n            if (leftCamera) {\r\n                leftCamera._isLeftCamera = true;\r\n            }\r\n            const rightCamera = this.createRigCamera(this.name + \"_R\", 1);\r\n            if (rightCamera) {\r\n                rightCamera._isRightCamera = true;\r\n            }\r\n            if (leftCamera && rightCamera) {\r\n                this._rigCameras.push(leftCamera);\r\n                this._rigCameras.push(rightCamera);\r\n            }\r\n        }\r\n\r\n        this._setRigMode(rigParams);\r\n\r\n        this._cascadePostProcessesToRigCams();\r\n        this.update();\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _setRigMode(rigParams: any) {\r\n        // no-op\r\n    }\r\n\r\n    /** @internal */\r\n    public _getVRProjectionMatrix(): Matrix {\r\n        Matrix.PerspectiveFovLHToRef(\r\n            this._cameraRigParams.vrMetrics.aspectRatioFov,\r\n            this._cameraRigParams.vrMetrics.aspectRatio,\r\n            this.minZ,\r\n            this.maxZ,\r\n            this._cameraRigParams.vrWorkMatrix,\r\n            true,\r\n            this.getEngine().isNDCHalfZRange\r\n        );\r\n        this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);\r\n        return this._projectionMatrix;\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        //Here for WebVR\r\n    }\r\n\r\n    protected _updateWebVRCameraRotationMatrix() {\r\n        //Here for WebVR\r\n    }\r\n\r\n    /**\r\n     * This function MUST be overwritten by the different WebVR cameras available.\r\n     * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.\r\n     * @internal\r\n     */\r\n    public _getWebVRProjectionMatrix(): Matrix {\r\n        return Matrix.Identity();\r\n    }\r\n\r\n    /**\r\n     * This function MUST be overwritten by the different WebVR cameras available.\r\n     * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.\r\n     * @internal\r\n     */\r\n    public _getWebVRViewMatrix(): Matrix {\r\n        return Matrix.Identity();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setCameraRigParameter(name: string, value: any) {\r\n        if (!this._cameraRigParams) {\r\n            this._cameraRigParams = {};\r\n        }\r\n        this._cameraRigParams[name] = value;\r\n        //provisionnally:\r\n        if (name === \"interaxialDistance\") {\r\n            this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * needs to be overridden by children so sub has required properties to be copied\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * May need to be overridden by children\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        for (let i = 0; i < this._rigCameras.length; i++) {\r\n            this._rigCameras[i].minZ = this.minZ;\r\n            this._rigCameras[i].maxZ = this.maxZ;\r\n            this._rigCameras[i].fov = this.fov;\r\n            this._rigCameras[i].upVector.copyFrom(this.upVector);\r\n        }\r\n\r\n        // only update viewport when ANAGLYPH\r\n        if (this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {\r\n            this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _setupInputs() {}\r\n\r\n    /**\r\n     * Serialiaze the camera setup to a json representation\r\n     * @returns the JSON representation\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Type\r\n        serializationObject.type = this.getClassName();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        if (this.inputs) {\r\n            this.inputs.serialize(serializationObject);\r\n        }\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Clones the current camera.\r\n     * @param name The cloned camera name\r\n     * @param newParent The cloned camera's new parent (none by default)\r\n     * @returns the cloned camera\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null): Camera {\r\n        const camera = SerializationHelper.Clone(\r\n            Camera.GetConstructorFromName(this.getClassName(), name, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide),\r\n            this\r\n        );\r\n        camera.name = name;\r\n        camera.parent = newParent;\r\n\r\n        this.onClonedObservable.notifyObservers(camera);\r\n\r\n        return camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the direction of the camera relative to a given local axis.\r\n     * @param localAxis Defines the reference axis to provide a relative direction.\r\n     * @returns the direction\r\n     */\r\n    public getDirection(localAxis: Vector3): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the current camera absolute rotation\r\n     */\r\n    public get absoluteRotation(): Quaternion {\r\n        this.getWorldMatrix().decompose(undefined, this._absoluteRotation);\r\n\r\n        return this._absoluteRotation;\r\n    }\r\n\r\n    /**\r\n     * Gets the direction of the camera relative to a given local axis into a passed vector.\r\n     * @param localAxis Defines the reference axis to provide a relative direction.\r\n     * @param result Defines the vector to store the result in\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, result: Vector3): void {\r\n        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);\r\n    }\r\n\r\n    /**\r\n     * Gets a camera constructor for a given camera type\r\n     * @param type The type of the camera to construct (should be equal to one of the camera class name)\r\n     * @param name The name of the camera the result will be able to instantiate\r\n     * @param scene The scene the result will construct the camera in\r\n     * @param interaxial_distance In case of stereoscopic setup, the distance between both eyes\r\n     * @param isStereoscopicSideBySide In case of stereoscopic setup, should the sereo be side b side\r\n     * @returns a factory method to construct the camera\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    static GetConstructorFromName(type: string, name: string, scene: Scene, interaxial_distance: number = 0, isStereoscopicSideBySide: boolean = true): () => Camera {\r\n        const constructorFunc = Node.Construct(type, name, scene, {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            interaxial_distance: interaxial_distance,\r\n            isStereoscopicSideBySide: isStereoscopicSideBySide,\r\n        });\r\n\r\n        if (constructorFunc) {\r\n            return <() => Camera>constructorFunc;\r\n        }\r\n\r\n        // Default to universal camera\r\n        return () => Camera._CreateDefaultParsedCamera(name, scene);\r\n    }\r\n\r\n    /**\r\n     * Compute the world  matrix of the camera.\r\n     * @returns the camera world matrix\r\n     */\r\n    public computeWorldMatrix(): Matrix {\r\n        return this.getWorldMatrix();\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON and creates the camera from the parsed information\r\n     * @param parsedCamera The JSON to parse\r\n     * @param scene The scene to instantiate the camera in\r\n     * @returns the newly constructed camera\r\n     */\r\n    public static Parse(parsedCamera: any, scene: Scene): Camera {\r\n        const type = parsedCamera.type;\r\n        const construct = Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);\r\n\r\n        const camera = SerializationHelper.Parse(construct, parsedCamera, scene);\r\n\r\n        // Parent\r\n        if (parsedCamera.parentId !== undefined) {\r\n            camera._waitingParentId = parsedCamera.parentId;\r\n        }\r\n\r\n        // Parent instance index\r\n        if (parsedCamera.parentInstanceIndex !== undefined) {\r\n            camera._waitingParentInstanceIndex = parsedCamera.parentInstanceIndex;\r\n        }\r\n\r\n        //If camera has an input manager, let it parse inputs settings\r\n        if (camera.inputs) {\r\n            camera.inputs.parse(parsedCamera);\r\n\r\n            camera._setupInputs();\r\n        }\r\n\r\n        if (parsedCamera.upVector) {\r\n            camera.upVector = Vector3.FromArray(parsedCamera.upVector); // need to force the upVector\r\n        }\r\n\r\n        if ((<any>camera).setPosition) {\r\n            // need to force position\r\n            camera.position.copyFromFloats(0, 0, 0);\r\n            (<any>camera).setPosition(Vector3.FromArray(parsedCamera.position));\r\n        }\r\n\r\n        // Target\r\n        if (parsedCamera.target) {\r\n            if ((<any>camera).setTarget) {\r\n                (<any>camera).setTarget(Vector3.FromArray(parsedCamera.target));\r\n            }\r\n        }\r\n\r\n        // Apply 3d rig, when found\r\n        if (parsedCamera.cameraRigMode) {\r\n            const rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};\r\n            camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);\r\n        }\r\n\r\n        // Animations\r\n        if (parsedCamera.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedCamera.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    camera.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(camera, parsedCamera, scene);\r\n        }\r\n\r\n        if (parsedCamera.autoAnimate) {\r\n            scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\r\n        if (parsedCamera.isEnabled !== undefined) {\r\n            camera.setEnabled(parsedCamera.isEnabled);\r\n        }\r\n\r\n        return camera;\r\n    }\r\n}\r\n","import type { IKeyboardEvent } from \"./deviceInputEvents\";\r\n\r\n/**\r\n * Gather the list of keyboard event types as constants.\r\n */\r\nexport class KeyboardEventTypes {\r\n    /**\r\n     * The keydown event is fired when a key becomes active (pressed).\r\n     */\r\n    public static readonly KEYDOWN = 0x01;\r\n    /**\r\n     * The keyup event is fired when a key has been released.\r\n     */\r\n    public static readonly KEYUP = 0x02;\r\n}\r\n\r\n/**\r\n * This class is used to store keyboard related info for the onKeyboardObservable event.\r\n */\r\nexport class KeyboardInfo {\r\n    /**\r\n     * Instantiates a new keyboard info.\r\n     * This class is used to store keyboard related info for the onKeyboardObservable event.\r\n     * @param type Defines the type of event (KeyboardEventTypes)\r\n     * @param event Defines the related dom event\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the type of event (KeyboardEventTypes)\r\n         */\r\n        public type: number,\r\n        /**\r\n         * Defines the related dom event\r\n         */\r\n        public event: IKeyboardEvent\r\n    ) {}\r\n}\r\n\r\n/**\r\n * This class is used to store keyboard related info for the onPreKeyboardObservable event.\r\n * Set the skipOnKeyboardObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onKeyboardObservable\r\n */\r\nexport class KeyboardInfoPre extends KeyboardInfo {\r\n    /**\r\n     * Defines whether the engine should skip the next onKeyboardObservable associated to this pre.\r\n     */\r\n    public skipOnKeyboardObservable: boolean;\r\n\r\n    /**\r\n     * Defines whether the engine should skip the next onKeyboardObservable associated to this pre.\r\n     * @deprecated use skipOnKeyboardObservable property instead\r\n     */\r\n    public get skipOnPointerObservable() {\r\n        return this.skipOnKeyboardObservable;\r\n    }\r\n    public set skipOnPointerObservable(value) {\r\n        this.skipOnKeyboardObservable = value;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new keyboard pre info.\r\n     * This class is used to store keyboard related info for the onPreKeyboardObservable event.\r\n     * @param type Defines the type of event (KeyboardEventTypes)\r\n     * @param event Defines the related dom event\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the type of event (KeyboardEventTypes)\r\n         */\r\n        public type: number,\r\n        /**\r\n         * Defines the related dom event\r\n         */\r\n        public event: IKeyboardEvent\r\n    ) {\r\n        super(type, event);\r\n        this.skipOnKeyboardObservable = false;\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { IMouseEvent, IPointerEvent } from \"./deviceInputEvents\";\r\nimport type { InputManager } from \"../Inputs/scene.inputManager\";\r\n\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\n\r\n/**\r\n * Gather the list of pointer event types as constants.\r\n */\r\nexport class PointerEventTypes {\r\n    /**\r\n     * The pointerdown event is fired when a pointer becomes active. For mouse, it is fired when the device transitions from no buttons depressed to at least one button depressed. For touch, it is fired when physical contact is made with the digitizer. For pen, it is fired when the stylus makes physical contact with the digitizer.\r\n     */\r\n    public static readonly POINTERDOWN = 0x01;\r\n    /**\r\n     * The pointerup event is fired when a pointer is no longer active.\r\n     */\r\n    public static readonly POINTERUP = 0x02;\r\n    /**\r\n     * The pointermove event is fired when a pointer changes coordinates.\r\n     */\r\n    public static readonly POINTERMOVE = 0x04;\r\n    /**\r\n     * The pointerwheel event is fired when a mouse wheel has been rotated.\r\n     */\r\n    public static readonly POINTERWHEEL = 0x08;\r\n    /**\r\n     * The pointerpick event is fired when a mesh or sprite has been picked by the pointer.\r\n     */\r\n    public static readonly POINTERPICK = 0x10;\r\n    /**\r\n     * The pointertap event is fired when a the object has been touched and released without drag.\r\n     */\r\n    public static readonly POINTERTAP = 0x20;\r\n    /**\r\n     * The pointerdoubletap event is fired when a the object has been touched and released twice without drag.\r\n     */\r\n    public static readonly POINTERDOUBLETAP = 0x40;\r\n}\r\n\r\n/**\r\n * Base class of pointer info types.\r\n */\r\nexport class PointerInfoBase {\r\n    /**\r\n     * Instantiates the base class of pointers info.\r\n     * @param type Defines the type of event (PointerEventTypes)\r\n     * @param event Defines the related dom event\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the type of event (PointerEventTypes)\r\n         */\r\n        public type: number,\r\n        /**\r\n         * Defines the related dom event\r\n         */\r\n        public event: IMouseEvent\r\n    ) {}\r\n}\r\n\r\n/**\r\n * This class is used to store pointer related info for the onPrePointerObservable event.\r\n * Set the skipOnPointerObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onPointerObservable\r\n */\r\nexport class PointerInfoPre extends PointerInfoBase {\r\n    /**\r\n     * Ray from a pointer if available (eg. 6dof controller)\r\n     */\r\n    public ray: Nullable<Ray> = null;\r\n\r\n    /**\r\n     * Defines picking info coming from a near interaction (proximity instead of ray-based picking)\r\n     */\r\n    public nearInteractionPickingInfo: Nullable<PickingInfo>;\r\n\r\n    /**\r\n     * The original picking info that was used to trigger the pointer event\r\n     */\r\n    public originalPickingInfo: Nullable<PickingInfo> = null;\r\n\r\n    /**\r\n     * Defines the local position of the pointer on the canvas.\r\n     */\r\n    public localPosition: Vector2;\r\n\r\n    /**\r\n     * Defines whether the engine should skip the next OnPointerObservable associated to this pre.\r\n     */\r\n    public skipOnPointerObservable: boolean;\r\n\r\n    /**\r\n     * Instantiates a PointerInfoPre to store pointer related info to the onPrePointerObservable event.\r\n     * @param type Defines the type of event (PointerEventTypes)\r\n     * @param event Defines the related dom event\r\n     * @param localX Defines the local x coordinates of the pointer when the event occured\r\n     * @param localY Defines the local y coordinates of the pointer when the event occured\r\n     */\r\n    constructor(type: number, event: IMouseEvent, localX: number, localY: number) {\r\n        super(type, event);\r\n        this.skipOnPointerObservable = false;\r\n        this.localPosition = new Vector2(localX, localY);\r\n    }\r\n}\r\n\r\n/**\r\n * This type contains all the data related to a pointer event in Babylon.js.\r\n * The event member is an instance of PointerEvent for all types except PointerWheel and is of type MouseWheelEvent when type equals PointerWheel. The different event types can be found in the PointerEventTypes class.\r\n */\r\nexport class PointerInfo extends PointerInfoBase {\r\n    private _pickInfo: Nullable<PickingInfo>;\r\n    private _inputManager: Nullable<InputManager>;\r\n\r\n    /**\r\n     * Defines the picking info associated with this PointerInfo object (if applicable)\r\n     */\r\n    public get pickInfo(): Nullable<PickingInfo> {\r\n        if (!this._pickInfo) {\r\n            this._generatePickInfo();\r\n        }\r\n\r\n        return this._pickInfo;\r\n    }\r\n    /**\r\n     * Instantiates a PointerInfo to store pointer related info to the onPointerObservable event.\r\n     * @param type Defines the type of event (PointerEventTypes)\r\n     * @param event Defines the related dom event\r\n     * @param pickInfo Defines the picking info associated to the info (if any)\r\n     * @param inputManager Defines the InputManager to use if there is no pickInfo\r\n     */\r\n    constructor(type: number, event: IMouseEvent, pickInfo: Nullable<PickingInfo>, inputManager: Nullable<InputManager> = null) {\r\n        super(type, event);\r\n        this._pickInfo = pickInfo;\r\n        this._inputManager = inputManager;\r\n    }\r\n\r\n    /**\r\n     * Generates the picking info if needed\r\n     */\r\n    /** @internal */\r\n    public _generatePickInfo(): void {\r\n        if (this._inputManager) {\r\n            this._pickInfo = this._inputManager._pickMove((this.event as IPointerEvent).pointerId);\r\n            this._inputManager._setRayOnPointerInfo(this._pickInfo, this.event);\r\n            this._inputManager = null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Data relating to a touch event on the screen.\r\n */\r\nexport interface PointerTouch {\r\n    /**\r\n     * X coordinate of touch.\r\n     */\r\n    x: number;\r\n    /**\r\n     * Y coordinate of touch.\r\n     */\r\n    y: number;\r\n    /**\r\n     * Id of touch. Unique for each finger.\r\n     */\r\n    pointerId: number;\r\n    /**\r\n     * Event type passed from DOM.\r\n     */\r\n    type: any;\r\n}\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Scene } from \"./scene\";\r\nimport type { Nullable } from \"./types\";\r\nimport { Matrix, Vector3 } from \"./Maths/math.vector\";\r\nimport type { Engine } from \"./Engines/engine\";\r\nimport type { IBehaviorAware, Behavior } from \"./Behaviors/behavior\";\r\nimport { serialize } from \"./Misc/decorators\";\r\nimport type { Observer } from \"./Misc/observable\";\r\nimport { Observable } from \"./Misc/observable\";\r\nimport { EngineStore } from \"./Engines/engineStore\";\r\nimport { _WarnImport } from \"./Misc/devTools\";\r\nimport type { AbstractActionManager } from \"./Actions/abstractActionManager\";\r\nimport type { IInspectable } from \"./Misc/iInspectable\";\r\nimport type { AbstractScene } from \"./abstractScene\";\r\nimport type { IAccessibilityTag } from \"./IAccessibilityTag\";\r\n\r\ndeclare type Animatable = import(\"./Animations/animatable\").Animatable;\r\ndeclare type AnimationPropertiesOverride = import(\"./Animations/animationPropertiesOverride\").AnimationPropertiesOverride;\r\ndeclare type Animation = import(\"./Animations/animation\").Animation;\r\ndeclare type AnimationRange = import(\"./Animations/animationRange\").AnimationRange;\r\ndeclare type AbstractMesh = import(\"./Meshes/abstractMesh\").AbstractMesh;\r\n\r\n/**\r\n * Defines how a node can be built from a string name.\r\n */\r\nexport type NodeConstructor = (name: string, scene: Scene, options?: any) => () => Node;\r\n\r\n/** @internal */\r\nclass _InternalNodeDataInfo {\r\n    public _doNotSerialize = false;\r\n    public _isDisposed = false;\r\n    public _sceneRootNodesIndex = -1;\r\n    public _isEnabled = true;\r\n    public _isParentEnabled = true;\r\n    public _isReady = true;\r\n    public _onEnabledStateChangedObservable = new Observable<boolean>();\r\n    public _onClonedObservable = new Observable<Node>();\r\n}\r\n\r\n/**\r\n * Node is the basic class for all scene objects (Mesh, Light, Camera.)\r\n */\r\nexport class Node implements IBehaviorAware<Node> {\r\n    protected _isDirty = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _AnimationRangeFactory = (_name: string, _from: number, _to: number): AnimationRange => {\r\n        throw _WarnImport(\"AnimationRange\");\r\n    };\r\n\r\n    private static _NodeConstructors: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * Add a new node constructor\r\n     * @param type defines the type name of the node to construct\r\n     * @param constructorFunc defines the constructor function\r\n     */\r\n    public static AddNodeConstructor(type: string, constructorFunc: NodeConstructor) {\r\n        this._NodeConstructors[type] = constructorFunc;\r\n    }\r\n\r\n    /**\r\n     * Returns a node constructor based on type name\r\n     * @param type defines the type name\r\n     * @param name defines the new node name\r\n     * @param scene defines the hosting scene\r\n     * @param options defines optional options to transmit to constructors\r\n     * @returns the new constructor or null\r\n     */\r\n    public static Construct(type: string, name: string, scene: Scene, options?: any): Nullable<() => Node> {\r\n        const constructorFunc = this._NodeConstructors[type];\r\n\r\n        if (!constructorFunc) {\r\n            return null;\r\n        }\r\n\r\n        return constructorFunc(name, scene, options);\r\n    }\r\n\r\n    private _nodeDataStorage = new _InternalNodeDataInfo();\r\n\r\n    /**\r\n     * Gets or sets the name of the node\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the id of the node\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or sets a string used to store user defined state for the node\r\n     */\r\n    @serialize()\r\n    public state = \"\";\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the node\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Gets or sets the accessibility tag to describe the node for accessibility purpose.\r\n     */\r\n    public set accessibilityTag(value: Nullable<IAccessibilityTag>) {\r\n        this._accessibilityTag = value;\r\n        this.onAccessibilityTagChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    public get accessibilityTag() {\r\n        return this._accessibilityTag;\r\n    }\r\n\r\n    protected _accessibilityTag: Nullable<IAccessibilityTag> = null;\r\n\r\n    public onAccessibilityTagChangedObservable = new Observable<Nullable<IAccessibilityTag>>();\r\n\r\n    /**\r\n     * Gets or sets a boolean used to define if the node must be serialized\r\n     */\r\n    public get doNotSerialize() {\r\n        if (this._nodeDataStorage._doNotSerialize) {\r\n            return true;\r\n        }\r\n\r\n        if (this._parentNode) {\r\n            return this._parentNode.doNotSerialize;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public set doNotSerialize(value: boolean) {\r\n        this._nodeDataStorage._doNotSerialize = value;\r\n    }\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Gets a list of Animations associated with the node\r\n     */\r\n    public animations = new Array<Animation>();\r\n    protected _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    /**\r\n     * Callback raised when the node is ready to be used\r\n     */\r\n    public onReady: Nullable<(node: Node) => void> = null;\r\n\r\n    /** @internal */\r\n    public _currentRenderId = -1;\r\n    private _parentUpdateId = -1;\r\n    /** @internal */\r\n    public _childUpdateId = -1;\r\n\r\n    /** @internal */\r\n    public _waitingParentId: Nullable<string> = null;\r\n    /** @internal */\r\n    public _waitingParentInstanceIndex: Nullable<string> = null;\r\n    /** @internal */\r\n    public _waitingParsedUniqueId: Nullable<number> = null;\r\n    /** @internal */\r\n    public _scene: Scene;\r\n    /** @internal */\r\n    public _cache: any = {};\r\n\r\n    protected _parentNode: Nullable<Node> = null;\r\n\r\n    /** @internal */\r\n    protected _children: Nullable<Node[]> = null;\r\n\r\n    /** @internal */\r\n    public _worldMatrix = Matrix.Identity();\r\n    /** @internal */\r\n    public _worldMatrixDeterminant = 0;\r\n    /** @internal */\r\n    public _worldMatrixDeterminantIsDirty = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the node has been disposed\r\n     * @returns true if the node was disposed\r\n     */\r\n    public isDisposed(): boolean {\r\n        return this._nodeDataStorage._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the parent of the node (without keeping the current position in the scene)\r\n     * @see https://doc.babylonjs.com/how_to/parenting\r\n     */\r\n    public set parent(parent: Nullable<Node>) {\r\n        if (this._parentNode === parent) {\r\n            return;\r\n        }\r\n\r\n        const previousParentNode = this._parentNode;\r\n\r\n        // Remove self from list of children of parent\r\n        if (this._parentNode && this._parentNode._children !== undefined && this._parentNode._children !== null) {\r\n            const index = this._parentNode._children.indexOf(this);\r\n            if (index !== -1) {\r\n                this._parentNode._children.splice(index, 1);\r\n            }\r\n\r\n            if (!parent && !this._nodeDataStorage._isDisposed) {\r\n                this._addToSceneRootNodes();\r\n            }\r\n        }\r\n\r\n        // Store new parent\r\n        this._parentNode = parent;\r\n\r\n        // Add as child to new parent\r\n        if (this._parentNode) {\r\n            if (this._parentNode._children === undefined || this._parentNode._children === null) {\r\n                this._parentNode._children = new Array<Node>();\r\n            }\r\n            this._parentNode._children.push(this);\r\n\r\n            if (!previousParentNode) {\r\n                this._removeFromSceneRootNodes();\r\n            }\r\n        }\r\n\r\n        // Enabled state\r\n        this._syncParentEnabledState();\r\n    }\r\n\r\n    public get parent(): Nullable<Node> {\r\n        return this._parentNode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _serializeAsParent(serializationObject: any): void {\r\n        serializationObject.parentId = this.uniqueId;\r\n    }\r\n\r\n    /** @internal */\r\n    public _addToSceneRootNodes() {\r\n        if (this._nodeDataStorage._sceneRootNodesIndex === -1) {\r\n            this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length;\r\n            this._scene.rootNodes.push(this);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _removeFromSceneRootNodes() {\r\n        if (this._nodeDataStorage._sceneRootNodesIndex !== -1) {\r\n            const rootNodes = this._scene.rootNodes;\r\n            const lastIdx = rootNodes.length - 1;\r\n            rootNodes[this._nodeDataStorage._sceneRootNodesIndex] = rootNodes[lastIdx];\r\n            rootNodes[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex;\r\n            this._scene.rootNodes.pop();\r\n            this._nodeDataStorage._sceneRootNodesIndex = -1;\r\n        }\r\n    }\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"Node\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"Node\";\r\n    }\r\n\r\n    /** @internal */\r\n    public readonly _isNode = true;\r\n\r\n    /**\r\n     * An event triggered when the mesh is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<Node>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<Node>> = null;\r\n    /**\r\n     * Sets a callback that will be raised when the node will be disposed\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the enabled state of the node changes\r\n     */\r\n    public get onEnabledStateChangedObservable(): Observable<boolean> {\r\n        return this._nodeDataStorage._onEnabledStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the node is cloned\r\n     */\r\n    public get onClonedObservable(): Observable<Node> {\r\n        return this._nodeDataStorage._onClonedObservable;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Node\r\n     * @param name the name and id to be given to this node\r\n     * @param scene the scene this node will be added to\r\n     */\r\n    constructor(name: string, scene: Nullable<Scene> = null) {\r\n        this.name = name;\r\n        this.id = name;\r\n        this._scene = <Scene>(scene || EngineStore.LastCreatedScene);\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._initCache();\r\n    }\r\n\r\n    /**\r\n     * Gets the scene of the node\r\n     * @returns a scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the engine of the node\r\n     * @returns a Engine\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._scene.getEngine();\r\n    }\r\n\r\n    // Behaviors\r\n    private _behaviors = new Array<Behavior<Node>>();\r\n\r\n    /**\r\n     * Attach a behavior to the node\r\n     * @see https://doc.babylonjs.com/features/behaviour\r\n     * @param behavior defines the behavior to attach\r\n     * @param attachImmediately defines that the behavior must be attached even if the scene is still loading\r\n     * @returns the current Node\r\n     */\r\n    public addBehavior(behavior: Behavior<Node>, attachImmediately = false): Node {\r\n        const index = this._behaviors.indexOf(behavior);\r\n\r\n        if (index !== -1) {\r\n            return this;\r\n        }\r\n\r\n        behavior.init();\r\n        if (this._scene.isLoading && !attachImmediately) {\r\n            // We defer the attach when the scene will be loaded\r\n            this._scene.onDataLoadedObservable.addOnce(() => {\r\n                behavior.attach(this);\r\n            });\r\n        } else {\r\n            behavior.attach(this);\r\n        }\r\n        this._behaviors.push(behavior);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove an attached behavior\r\n     * @see https://doc.babylonjs.com/features/behaviour\r\n     * @param behavior defines the behavior to attach\r\n     * @returns the current Node\r\n     */\r\n    public removeBehavior(behavior: Behavior<Node>): Node {\r\n        const index = this._behaviors.indexOf(behavior);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._behaviors[index].detach();\r\n        this._behaviors.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of attached behaviors\r\n     * @see https://doc.babylonjs.com/features/behaviour\r\n     */\r\n    public get behaviors(): Behavior<Node>[] {\r\n        return this._behaviors;\r\n    }\r\n\r\n    /**\r\n     * Gets an attached behavior by name\r\n     * @param name defines the name of the behavior to look for\r\n     * @see https://doc.babylonjs.com/features/behaviour\r\n     * @returns null if behavior was not found else the requested behavior\r\n     */\r\n    public getBehaviorByName(name: string): Nullable<Behavior<Node>> {\r\n        for (const behavior of this._behaviors) {\r\n            if (behavior.name === name) {\r\n                return behavior;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the latest update of the World matrix\r\n     * @returns a Matrix\r\n     */\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentRenderId !== this._scene.getRenderId()) {\r\n            this.computeWorldMatrix();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getWorldMatrixDeterminant(): number {\r\n        if (this._worldMatrixDeterminantIsDirty) {\r\n            this._worldMatrixDeterminantIsDirty = false;\r\n            this._worldMatrixDeterminant = this._worldMatrix.determinant();\r\n        }\r\n        return this._worldMatrixDeterminant;\r\n    }\r\n\r\n    /**\r\n     * Returns directly the latest state of the mesh World matrix.\r\n     * A Matrix is returned.\r\n     */\r\n    public get worldMatrixFromCache(): Matrix {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    // override it in derived class if you add new variables to the cache\r\n    // and call the parent class method\r\n    /** @internal */\r\n    public _initCache() {\r\n        this._cache = {};\r\n        this._cache.parent = undefined;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public updateCache(force?: boolean): void {\r\n        if (!force && this.isSynchronized()) {\r\n            return;\r\n        }\r\n\r\n        this._cache.parent = this.parent;\r\n\r\n        this._updateCache();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getActionManagerForTrigger(trigger?: number, _initialCall = true): Nullable<AbstractActionManager> {\r\n        if (!this.parent) {\r\n            return null;\r\n        }\r\n\r\n        return this.parent._getActionManagerForTrigger(trigger, false);\r\n    }\r\n\r\n    // override it in derived class if you add new variables to the cache\r\n    // and call the parent class method if !ignoreParentClass\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(_ignoreParentClass?: boolean): void {}\r\n\r\n    // override it in derived class if you add new variables to the cache\r\n    /** @internal */\r\n    public _isSynchronized(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markSyncedWithParent() {\r\n        if (this._parentNode) {\r\n            this._parentUpdateId = this._parentNode._childUpdateId;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public isSynchronizedWithParent(): boolean {\r\n        if (!this._parentNode) {\r\n            return true;\r\n        }\r\n\r\n        if (this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId) {\r\n            return false;\r\n        }\r\n\r\n        return this._parentNode.isSynchronized();\r\n    }\r\n\r\n    /** @internal */\r\n    public isSynchronized(): boolean {\r\n        if (this._cache.parent !== this._parentNode) {\r\n            this._cache.parent = this._parentNode;\r\n            return false;\r\n        }\r\n\r\n        if (this._parentNode && !this.isSynchronizedWithParent()) {\r\n            return false;\r\n        }\r\n\r\n        return this._isSynchronized();\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param _completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns true if the node is ready\r\n     */\r\n    public isReady(_completeCheck = false): boolean {\r\n        return this._nodeDataStorage._isReady;\r\n    }\r\n\r\n    /**\r\n     * Flag the  node as dirty (Forcing it to update everything)\r\n     * @param _property helps children apply precise \"dirtyfication\"\r\n     * @returns this node\r\n     */\r\n    public markAsDirty(_property?: string): Node {\r\n        this._currentRenderId = Number.MAX_VALUE;\r\n        this._isDirty = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Is this node enabled?\r\n     * If the node has a parent, all ancestors will be checked and false will be returned if any are false (not enabled), otherwise will return true\r\n     * @param checkAncestors indicates if this method should check the ancestors. The default is to check the ancestors. If set to false, the method will return the value of this node without checking ancestors\r\n     * @returns whether this node (and its parent) is enabled\r\n     */\r\n    public isEnabled(checkAncestors: boolean = true): boolean {\r\n        if (checkAncestors === false) {\r\n            return this._nodeDataStorage._isEnabled;\r\n        }\r\n\r\n        if (!this._nodeDataStorage._isEnabled) {\r\n            return false;\r\n        }\r\n\r\n        return this._nodeDataStorage._isParentEnabled;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _syncParentEnabledState() {\r\n        this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : true;\r\n\r\n        if (this._children) {\r\n            this._children.forEach((c) => {\r\n                c._syncParentEnabledState(); // Force children to update accordingly\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node\r\n     * @param value defines the new enabled state\r\n     */\r\n    public setEnabled(value: boolean): void {\r\n        if (this._nodeDataStorage._isEnabled === value) {\r\n            return;\r\n        }\r\n        this._nodeDataStorage._isEnabled = value;\r\n        this._syncParentEnabledState();\r\n        this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    /**\r\n     * Is this node a descendant of the given node?\r\n     * The function will iterate up the hierarchy until the ancestor was found or no more parents defined\r\n     * @param ancestor defines the parent node to inspect\r\n     * @returns a boolean indicating if this node is a descendant of the given node\r\n     */\r\n    public isDescendantOf(ancestor: Node): boolean {\r\n        if (this.parent) {\r\n            if (this.parent === ancestor) {\r\n                return true;\r\n            }\r\n\r\n            return this.parent.isDescendantOf(ancestor);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getDescendants(results: Node[], directDescendantsOnly: boolean = false, predicate?: (node: Node) => boolean): void {\r\n        if (!this._children) {\r\n            return;\r\n        }\r\n\r\n        for (let index = 0; index < this._children.length; index++) {\r\n            const item = this._children[index];\r\n\r\n            if (!predicate || predicate(item)) {\r\n                results.push(item);\r\n            }\r\n\r\n            if (!directDescendantsOnly) {\r\n                item._getDescendants(results, false, predicate);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Will return all nodes that have this node as ascendant\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns all children nodes of all types\r\n     */\r\n    public getDescendants<T extends Node>(directDescendantsOnly?: boolean, predicate?: (node: Node) => node is T): T[];\r\n\r\n    /**\r\n     * Will return all nodes that have this node as ascendant\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns all children nodes of all types\r\n     */\r\n    public getDescendants(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): Node[];\r\n\r\n    /**\r\n     * Will return all nodes that have this node as ascendant\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns all children nodes of all types\r\n     */\r\n    public getDescendants(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): Node[] {\r\n        const results = new Array<Node>();\r\n\r\n        this._getDescendants(results, directDescendantsOnly, predicate);\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Get all child-meshes of this node\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: false)\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns an array of AbstractMesh\r\n     */\r\n    public getChildMeshes<T extends AbstractMesh>(directDescendantsOnly?: boolean, predicate?: (node: Node) => node is T): T[];\r\n\r\n    /**\r\n     * Get all child-meshes of this node\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: false)\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns an array of AbstractMesh\r\n     */\r\n    public getChildMeshes(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): AbstractMesh[];\r\n\r\n    /**\r\n     * Get all child-meshes of this node\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: false)\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns an array of AbstractMesh\r\n     */\r\n    public getChildMeshes(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): AbstractMesh[] {\r\n        const results: Array<AbstractMesh> = [];\r\n        this._getDescendants(results, directDescendantsOnly, (node: Node) => {\r\n            return (!predicate || predicate(node)) && (<AbstractMesh>node).cullingStrategy !== undefined;\r\n        });\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Get all direct children of this node\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: true)\r\n     * @returns an array of Node\r\n     */\r\n    public getChildren<T extends Node>(predicate?: (node: Node) => node is T, directDescendantsOnly?: boolean): T[];\r\n\r\n    /**\r\n     * Get all direct children of this node\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: true)\r\n     * @returns an array of Node\r\n     */\r\n    public getChildren(predicate?: (node: Node) => boolean, directDescendantsOnly?: boolean): Node[];\r\n\r\n    /**\r\n     * Get all direct children of this node\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: true)\r\n     * @returns an array of Node\r\n     */\r\n    public getChildren(predicate?: (node: Node) => boolean, directDescendantsOnly = true): Node[] {\r\n        return this.getDescendants(directDescendantsOnly, predicate);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setReady(state: boolean): void {\r\n        if (state === this._nodeDataStorage._isReady) {\r\n            return;\r\n        }\r\n\r\n        if (!state) {\r\n            this._nodeDataStorage._isReady = false;\r\n            return;\r\n        }\r\n\r\n        if (this.onReady) {\r\n            this.onReady(this);\r\n        }\r\n        this._nodeDataStorage._isReady = true;\r\n    }\r\n\r\n    /**\r\n     * Get an animation by name\r\n     * @param name defines the name of the animation to look for\r\n     * @returns null if not found else the requested animation\r\n     */\r\n    public getAnimationByName(name: string): Nullable<Animation> {\r\n        for (let i = 0; i < this.animations.length; i++) {\r\n            const animation = this.animations[i];\r\n\r\n            if (animation.name === name) {\r\n                return animation;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates an animation range for this node\r\n     * @param name defines the name of the range\r\n     * @param from defines the starting key\r\n     * @param to defines the end key\r\n     */\r\n    public createAnimationRange(name: string, from: number, to: number): void {\r\n        // check name not already in use\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = Node._AnimationRangeFactory(name, from, to);\r\n            for (let i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {\r\n                if (this.animations[i]) {\r\n                    this.animations[i].createRange(name, from, to);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a specific animation range\r\n     * @param name defines the name of the range to delete\r\n     * @param deleteFrames defines if animation frames from the range must be deleted as well\r\n     */\r\n    public deleteAnimationRange(name: string, deleteFrames = true): void {\r\n        for (let i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {\r\n            if (this.animations[i]) {\r\n                this.animations[i].deleteRange(name, deleteFrames);\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Get an animation range by name\r\n     * @param name defines the name of the animation range to look for\r\n     * @returns null if not found else the requested animation range\r\n     */\r\n    public getAnimationRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all animation ranges defined on this node\r\n     * @returns an array\r\n     */\r\n    public getAnimationRanges(): Nullable<AnimationRange>[] {\r\n        const animationRanges: Nullable<AnimationRange>[] = [];\r\n        let name: string;\r\n        for (name in this._ranges) {\r\n            animationRanges.push(this._ranges[name]);\r\n        }\r\n        return animationRanges;\r\n    }\r\n\r\n    /**\r\n     * Will start the animation sequence\r\n     * @param name defines the range frames for animation sequence\r\n     * @param loop defines if the animation should loop (false by default)\r\n     * @param speedRatio defines the speed factor in which to run the animation (1 by default)\r\n     * @param onAnimationEnd defines a function to be executed when the animation ended (undefined by default)\r\n     * @returns the object created for this animation. If range does not exist, it will return null\r\n     */\r\n    public beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable> {\r\n        const range = this.getAnimationRange(name);\r\n\r\n        if (!range) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Serialize animation ranges into a JSON compatible object\r\n     * @returns serialization object\r\n     */\r\n    public serializeAnimationRanges(): any {\r\n        const serializationRanges = [];\r\n        for (const name in this._ranges) {\r\n            const localRange = this._ranges[name];\r\n            if (!localRange) {\r\n                continue;\r\n            }\r\n            const range: any = {};\r\n            range.name = name;\r\n            range.from = localRange.from;\r\n            range.to = localRange.to;\r\n            serializationRanges.push(range);\r\n        }\r\n        return serializationRanges;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @param _force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(_force?: boolean): Matrix {\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        this._nodeDataStorage._isDisposed = true;\r\n\r\n        if (!doNotRecurse) {\r\n            const nodes = this.getDescendants(true);\r\n            for (const node of nodes) {\r\n                node.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n            }\r\n        }\r\n\r\n        if (!this.parent) {\r\n            this._removeFromSceneRootNodes();\r\n        } else {\r\n            this.parent = null;\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.onEnabledStateChangedObservable.clear();\r\n        this.onClonedObservable.clear();\r\n\r\n        // Behaviors\r\n        for (const behavior of this._behaviors) {\r\n            behavior.detach();\r\n        }\r\n\r\n        this._behaviors.length = 0;\r\n\r\n        this.metadata = null;\r\n    }\r\n\r\n    /**\r\n     * Parse animation range data from a serialization object and store them into a given node\r\n     * @param node defines where to store the animation ranges\r\n     * @param parsedNode defines the serialization object to read data from\r\n     * @param _scene defines the hosting scene\r\n     */\r\n    public static ParseAnimationRanges(node: Node, parsedNode: any, _scene: Scene): void {\r\n        if (parsedNode.ranges) {\r\n            for (let index = 0; index < parsedNode.ranges.length; index++) {\r\n                const data = parsedNode.ranges[index];\r\n                node.createAnimationRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Return the minimum and maximum world vectors of the entire hierarchy under current node\r\n     * @param includeDescendants Include bounding info from descendants as well (true by default)\r\n     * @param predicate defines a callback function that can be customize to filter what meshes should be included in the list used to compute the bounding vectors\r\n     * @returns the new bounding vectors\r\n     */\r\n    public getHierarchyBoundingVectors(includeDescendants = true, predicate: Nullable<(abstractMesh: AbstractMesh) => boolean> = null): { min: Vector3; max: Vector3 } {\r\n        // Ensures that all world matrix will be recomputed.\r\n        this.getScene().incrementRenderId();\r\n\r\n        this.computeWorldMatrix(true);\r\n\r\n        let min: Vector3;\r\n        let max: Vector3;\r\n\r\n        const thisAbstractMesh = this as Node as AbstractMesh;\r\n        if (thisAbstractMesh.getBoundingInfo && thisAbstractMesh.subMeshes) {\r\n            // If this is an abstract mesh get its bounding info\r\n            const boundingInfo = thisAbstractMesh.getBoundingInfo();\r\n            min = boundingInfo.boundingBox.minimumWorld.clone();\r\n            max = boundingInfo.boundingBox.maximumWorld.clone();\r\n        } else {\r\n            min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n            max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n        }\r\n\r\n        if (includeDescendants) {\r\n            const descendants = this.getDescendants(false);\r\n\r\n            for (const descendant of descendants) {\r\n                const childMesh = <AbstractMesh>descendant;\r\n                childMesh.computeWorldMatrix(true);\r\n\r\n                // Filters meshes based on custom predicate function.\r\n                if (predicate && !predicate(childMesh)) {\r\n                    continue;\r\n                }\r\n\r\n                //make sure we have the needed params to get mix and max\r\n                if (!childMesh.getBoundingInfo || childMesh.getTotalVertices() === 0) {\r\n                    continue;\r\n                }\r\n\r\n                const childBoundingInfo = childMesh.getBoundingInfo();\r\n                const boundingBox = childBoundingInfo.boundingBox;\r\n\r\n                const minBox = boundingBox.minimumWorld;\r\n                const maxBox = boundingBox.maximumWorld;\r\n\r\n                Vector3.CheckExtends(minBox, min, max);\r\n                Vector3.CheckExtends(maxBox, min, max);\r\n            }\r\n        }\r\n\r\n        return {\r\n            min: min,\r\n            max: max,\r\n        };\r\n    }\r\n}\r\n"],"names":["Camera","constructor","name","position","scene","setActiveOnSceneIfNoneActive","super","_position","Zero","_upVector","Up","_orthoLeft","_orthoRight","_orthoBottom","_orthoTop","fov","projectionPlaneTilt","minZ","maxZ","inertia","_mode","PERSPECTIVE_CAMERA","isIntermediate","viewport","layerMask","fovMode","FOVMODE_VERTICAL_FIXED","cameraRigMode","RIG_MODE_NONE","customRenderTargets","Array","outputRenderTarget","onViewMatrixChangedObservable","onProjectionMatrixChangedObservable","onAfterCheckInputsObservable","onRestoreStateObservable","isRigCamera","_rigCameras","_webvrViewMatrix","Identity","_skipRendering","_projectionMatrix","_postProcesses","_activeMeshes","_globalPosition","_computedViewMatrix","_doNotComputeProjectionMatrix","_transformMatrix","_refreshFrustumPlanes","_absoluteRotation","_isCamera","_isLeftCamera","_isRightCamera","this","getScene","addCamera","activeCamera","renderPassId","getEngine","createRenderPassId","newPosition","upVector","vec","screenArea","x","y","mode","Math","tan","getAspectRatio","halfWidth","getRenderWidth","halfHeight","getRenderHeight","orthoRight","orthoLeft","orthoTop","orthoBottom","value","rigCamera","storeState","_stateStored","_storedFov","_restoreStateValues","restoreState","notifyObservers","getClassName","toString","fullDetails","ret","animations","i","length","applyVerticalCorrection","rot","absoluteRotation","toEulerAngles","_scene","useRightHandedSystem","globalPosition","getActiveMeshes","isActiveMesh","mesh","indexOf","isReady","completeCheck","pp","_initCache","_cache","Number","MAX_VALUE","undefined","aspectRatio","renderWidth","renderHeight","_updateCache","ignoreParentClass","copyFrom","_isSynchronized","_isSynchronizedViewMatrix","_isSynchronizedProjectionMatrix","equals","isSynchronizedWithParent","check","engine","attachControl","_ignored","_noPreventDefault","detachControl","update","_checkInputs","_updateRigCameras","rigCameras","rigPostProcess","_rigPostProcess","_getFirstPostProcess","ppIndex","_cascadePostProcessesToRigCams","firstPostProcess","markTextureDirty","len","cam","getEffectName","slice","concat","attachPostProcess","postProcess","insertAt","isReusable","Error","push","splice","prePassRenderer","markAsDirty","detachPostProcess","idx","getWorldMatrix","getViewMatrix","_worldMatrix","_getViewMatrix","force","updateCache","_currentRenderId","getRenderId","_childUpdateId","_cameraRigParams","vrPreViewMatrix","multiplyToRef","parent","invertToRef","freezeProjectionMatrix","projection","unfreezeProjectionMatrix","getProjectionMatrix","reverseDepth","useReverseDepthBuffer","PerspectiveFovRHToRef","PerspectiveFovLHToRef","isNDCHalfZRange","OrthoOffCenterRHToRef","OrthoOffCenterLHToRef","getTransformationMatrix","_updateFrustumPlanes","_frustumPlanes","GetPlanesToRef","GetPlanes","isInFrustum","target","checkRigCameras","result","forEach","isCompletelyInFrustum","getForwardRay","transform","origin","getForwardRayToRef","refRay","dispose","doNotRecurse","disposeMaterialAndTextures","clear","inputs","stopAnimation","removeCamera","camera","pop","_parentContainer","index","cameras","releaseRenderPassId","isLeftCamera","isRightCamera","leftCamera","rightCamera","getLeftTarget","getTarget","getRightTarget","setCameraRigMode","rigParams","interaxialDistance","stereoHalfAngle","ToRadians","createRigCamera","_setRigMode","_getVRProjectionMatrix","vrMetrics","aspectRatioFov","vrWorkMatrix","vrHMatrix","_updateCameraRotationMatrix","_updateWebVRCameraRotationMatrix","_getWebVRProjectionMatrix","_getWebVRViewMatrix","setCameraRigParameter","cameraIndex","RIG_MODE_STEREOSCOPIC_ANAGLYPH","_setupInputs","serialize","serializationObject","Serialize","uniqueId","type","_serializeAsParent","AppendSerializedAnimations","ranges","serializeAnimationRanges","isEnabled","clone","newParent","Clone","GetConstructorFromName","isStereoscopicSideBySide","onClonedObservable","getDirection","localAxis","getDirectionToRef","decompose","TransformNormalToRef","interaxial_distance","Construct","_CreateDefaultParsedCamera","computeWorldMatrix","Parse","parsedCamera","construct","parentId","_waitingParentId","parentInstanceIndex","_waitingParentInstanceIndex","parse","FromArray","setPosition","copyFromFloats","setTarget","animationIndex","parsedAnimation","internalClass","ParseAnimationRanges","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","setEnabled","ORTHOGRAPHIC_CAMERA","FOVMODE_HORIZONTAL_FIXED","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED","RIG_MODE_STEREOSCOPIC_OVERUNDER","RIG_MODE_STEREOSCOPIC_INTERLACED","RIG_MODE_VR","RIG_MODE_WEBVR","RIG_MODE_CUSTOM","ForceAttachControlToAlwaysPreventDefault","KeyboardEventTypes","KEYDOWN","KEYUP","KeyboardInfo","event","KeyboardInfoPre","skipOnKeyboardObservable","skipOnPointerObservable","PointerEventTypes","POINTERDOWN","POINTERUP","POINTERMOVE","POINTERWHEEL","POINTERPICK","POINTERTAP","POINTERDOUBLETAP","PointerInfoBase","PointerInfoPre","localX","localY","ray","originalPickingInfo","localPosition","PointerInfo","pickInfo","inputManager","_pickInfo","_inputManager","_generatePickInfo","_pickMove","pointerId","_setRayOnPointerInfo","_InternalNodeDataInfo","_doNotSerialize","_isDisposed","_sceneRootNodesIndex","_isEnabled","_isParentEnabled","_isReady","_onEnabledStateChangedObservable","_onClonedObservable","Node","_isDirty","_nodeDataStorage","state","metadata","reservedDataStore","_accessibilityTag","onAccessibilityTagChangedObservable","_ranges","onReady","_parentUpdateId","_waitingParsedUniqueId","_parentNode","_children","_worldMatrixDeterminant","_worldMatrixDeterminantIsDirty","_animationPropertiesOverride","_isNode","onDisposeObservable","_onDisposeObserver","_behaviors","id","LastCreatedScene","getUniqueId","AddNodeConstructor","constructorFunc","_NodeConstructors","options","accessibilityTag","doNotSerialize","isDisposed","previousParentNode","_addToSceneRootNodes","_removeFromSceneRootNodes","_syncParentEnabledState","rootNodes","lastIdx","animationPropertiesOverride","onDispose","callback","remove","add","onEnabledStateChangedObservable","addBehavior","behavior","attachImmediately","init","isLoading","onDataLoadedObservable","addOnce","attach","removeBehavior","detach","behaviors","getBehaviorByName","_getWorldMatrixDeterminant","determinant","worldMatrixFromCache","isSynchronized","_getActionManagerForTrigger","trigger","_initialCall","_ignoreParentClass","_markSyncedWithParent","_completeCheck","_property","checkAncestors","c","isDescendantOf","ancestor","_getDescendants","results","directDescendantsOnly","predicate","item","getDescendants","getChildMeshes","node","cullingStrategy","getChildren","_setReady","getAnimationByName","animation","createAnimationRange","from","to","_AnimationRangeFactory","nAnimations","createRange","deleteAnimationRange","deleteFrames","deleteRange","getAnimationRange","getAnimationRanges","animationRanges","loop","speedRatio","onAnimationEnd","range","serializationRanges","localRange","_force","nodes","parsedNode","data","getHierarchyBoundingVectors","includeDescendants","min","max","incrementRenderId","thisAbstractMesh","getBoundingInfo","subMeshes","boundingInfo","boundingBox","minimumWorld","maximumWorld","descendants","descendant","childMesh","getTotalVertices","minBox","maxBox","CheckExtends","_name","_from","_to"],"sourceRoot":""}