{"version":3,"file":"js/893.babylonBundle.js","mappings":"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","sources":["webpack://pro-racer/./assets/glb/samsung-controller.glb","webpack://pro-racer/./assets/environment/room.env","webpack://pro-racer/./src/scenes/loadModelAndEnv.ts","webpack://pro-racer/../lts/core/generated/Meshes/Builders/boxBuilder.ts","webpack://pro-racer/../lts/core/generated/Meshes/Builders/planeBuilder.ts"],"sourcesContent":["export default __webpack_public_path__ + \"4bf4f35110efeb71a363c4d654c5c13f.glb\";","export default __webpack_public_path__ + \"fa8d79b17b6be7285a4edd38e874fd1f.env\";","import { Engine } from \"@babylonjs/core/Engines/engine\";\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\nimport { CreateSceneClass } from \"../createScene\";\nimport { SceneLoader } from \"@babylonjs/core/Loading/sceneLoader\";\nimport { CubeTexture } from \"@babylonjs/core/Materials/Textures/cubeTexture\";\nimport { EnvironmentHelper } from \"@babylonjs/core/Helpers/environmentHelper\";\n\n// required imports\nimport \"@babylonjs/core/Loading/loadingScreen\";\nimport \"@babylonjs/loaders/glTF\";\nimport \"@babylonjs/core/Materials/standardMaterial\";\nimport \"@babylonjs/core/Materials/Textures/Loaders/envTextureLoader\";\n\n\n// digital assets\nimport controllerModel from \"../../assets/glb/samsung-controller.glb\";\nimport roomEnvironment from \"../../assets/environment/room.env\"\n\nexport class LoadModelAndEnvScene implements CreateSceneClass {\n    createScene = async (\n        engine: Engine,\n        canvas: HTMLCanvasElement\n    ): Promise<Scene> => {\n        // This creates a basic Babylon Scene object (non-mesh)\n        const scene = new Scene(engine);\n\n        // This creates and positions a free camera (non-mesh)\n        const camera = new ArcRotateCamera(\n            \"my first camera\",\n            0,\n            Math.PI / 3,\n            10,\n            new Vector3(0, 0, 0),\n            scene\n        );\n\n        // This targets the camera to scene origin\n        camera.setTarget(Vector3.Zero());\n\n        // This attaches the camera to the canvas\n        camera.attachControl(canvas, true);\n\n        camera.useFramingBehavior = true;\n\n        // load the environment file\n        scene.environmentTexture = new CubeTexture(roomEnvironment, scene);\n\n        // if not setting the envtext of the scene, we have to load the DDS module as well\n        new EnvironmentHelper( {\n            skyboxTexture: roomEnvironment,\n            createGround: false\n        }, scene)\n\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n        const light = new HemisphericLight(\n            \"light\",\n            new Vector3(0, 1, 0),\n            scene\n        );\n\n        // Default intensity is 1. Let's dim the light a small amount\n        light.intensity = 0.7;\n\n        const importResult = await SceneLoader.ImportMeshAsync(\n            \"\",\n            \"\",\n            controllerModel,\n            scene,\n            undefined,\n            \".glb\"\n        );\n\n        // just scale it so we can see it better\n        importResult.meshes[0].scaling.scaleInPlace(10);\n\n        return scene;\n    };\n}\n\nexport default new LoadModelAndEnvScene();\n","import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a box\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreateBoxVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    wrap?: boolean;\r\n    topBaseAt?: number;\r\n    bottomBaseAt?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n    let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\r\n    const normals = [\r\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0,\r\n        1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,\r\n    ];\r\n    const uvs = [];\r\n    let positions = [];\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const wrap = options.wrap || false;\r\n    let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\r\n    let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\r\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\r\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\r\n    const topOrder = [2, 0, 3, 1];\r\n    const bottomOrder = [2, 0, 1, 3];\r\n    let topIndex = topOrder[topBaseAt];\r\n    let bottomIndex = bottomOrder[bottomBaseAt];\r\n    let basePositions = [\r\n        1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,\r\n        1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1,\r\n    ];\r\n    if (wrap) {\r\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\r\n        basePositions = [\r\n            -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1,\r\n        ];\r\n        let topFaceBase: any = [\r\n            [1, 1, 1],\r\n            [-1, 1, 1],\r\n            [-1, 1, -1],\r\n            [1, 1, -1],\r\n        ];\r\n        let bottomFaceBase: any = [\r\n            [-1, -1, 1],\r\n            [1, -1, 1],\r\n            [1, -1, -1],\r\n            [-1, -1, -1],\r\n        ];\r\n        const topFaceOrder: any = [17, 18, 19, 16];\r\n        const bottomFaceOrder: any = [22, 23, 20, 21];\r\n        while (topIndex > 0) {\r\n            topFaceBase.unshift(topFaceBase.pop());\r\n            topFaceOrder.unshift(topFaceOrder.pop());\r\n            topIndex--;\r\n        }\r\n        while (bottomIndex > 0) {\r\n            bottomFaceBase.unshift(bottomFaceBase.pop());\r\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\r\n            bottomIndex--;\r\n        }\r\n        topFaceBase = topFaceBase.flat();\r\n        bottomFaceBase = bottomFaceBase.flat();\r\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\r\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\r\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\r\n    }\r\n    const scaleArray = [width / 2, height / 2, depth / 2];\r\n    positions = basePositions.reduce((accumulator: Array<number>, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n    const colors = [];\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 6; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    // Create each face in turn.\r\n    for (let index = 0; index < nbFaces; index++) {\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a box mesh\r\n * * The parameter `size` sets the size (float) of each box side (default 1)\r\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#box\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateBox(\r\n    name: string,\r\n    options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n        topBaseAt?: number;\r\n        bottomBaseAt?: number;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateBox directly\r\n */\r\nexport const BoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateBox,\r\n};\r\n\r\n// Side effects\r\nVertexData.CreateBox = CreateBoxVertexData;\r\n\r\n(Mesh as any).CreateBox = (name: string, size: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateBox(name, options, scene);\r\n};\r\n","import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Plane } from \"../../Maths/math.plane\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Plane\r\n * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n * * size sets the width and height of the plane to the value of size, optional default 1\r\n * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreatePlaneVertexData(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    const width: number = options.width || options.size || 1;\r\n    const height: number = options.height || options.size || 1;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Vertices\r\n    const halfWidth = width / 2.0;\r\n    const halfHeight = height / 2.0;\r\n\r\n    positions.push(-halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\r\n\r\n    positions.push(halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\r\n\r\n    positions.push(halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\r\n\r\n    positions.push(-halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\r\n\r\n    // Indices\r\n    indices.push(0);\r\n    indices.push(1);\r\n    indices.push(2);\r\n\r\n    indices.push(0);\r\n    indices.push(2);\r\n    indices.push(3);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a plane mesh\r\n * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\r\n * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\r\n * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param options.sourcePlane\r\n * @param scene defines the hosting scene\r\n * @returns the plane mesh\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#plane\r\n */\r\nexport function CreatePlane(\r\n    name: string,\r\n    options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4; updatable?: boolean; sourcePlane?: Plane } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const plane = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreatePlaneVertexData(options);\r\n\r\n    vertexData.applyToMesh(plane, options.updatable);\r\n\r\n    if (options.sourcePlane) {\r\n        plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);\r\n        plane.setDirection(options.sourcePlane.normal.scale(-1));\r\n    }\r\n\r\n    return plane;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const PlaneBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreatePlane,\r\n};\r\n\r\nVertexData.CreatePlane = CreatePlaneVertexData;\r\n(Mesh as any).CreatePlane = (name: string, size: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        width: size,\r\n        height: size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreatePlane(name, options, scene);\r\n};\r\n"],"names":["LoadModelAndEnvScene","createScene","async","engine","canvas","scene","camera","Math","PI","setTarget","attachControl","useFramingBehavior","environmentTexture","room","skyboxTexture","createGround","intensity","undefined","meshes","scaling","scaleInPlace","CreateBoxVertexData","options","indices","normals","uvs","positions","width","size","height","depth","wrap","topBaseAt","bottomBaseAt","topIndex","bottomIndex","basePositions","topFaceBase","bottomFaceBase","topFaceOrder","bottomFaceOrder","unshift","pop","flat","concat","push","scaleArray","reduce","accumulator","currentValue","currentIndex","sideOrientation","faceUV","Array","faceColors","colors","f","index","z","w","x","y","c","r","g","b","a","frontUVs","backUVs","vertexData","totalColors","CreateBox","name","box","_originalBuilderSideOrientation","applyToMesh","updatable","BoxBuilder","CreatePlaneVertexData","halfWidth","halfHeight","CreatePlane","plane","sourcePlane","translate","normal","d","setDirection","scale","PlaneBuilder"],"sourceRoot":""}