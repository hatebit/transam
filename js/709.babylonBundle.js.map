{"version":3,"file":"js/709.babylonBundle.js","mappings":"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","sources":["webpack://trans-america/../lts/core/generated/Cameras/Inputs/BaseCameraPointersInput.ts","webpack://trans-america/../lts/core/generated/Cameras/Inputs/followCameraKeyboardMoveInput.ts","webpack://trans-america/../lts/core/generated/Cameras/Inputs/followCameraMouseWheelInput.ts","webpack://trans-america/../lts/core/generated/Cameras/Inputs/followCameraPointersInput.ts","webpack://trans-america/../lts/core/generated/Cameras/cameraInputsManager.ts","webpack://trans-america/../lts/core/generated/Cameras/followCamera.ts","webpack://trans-america/../lts/core/generated/Cameras/followCameraInputsManager.ts","webpack://trans-america/../lts/core/generated/Cameras/targetCamera.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo, PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\r\n     */\r\n    protected _altKey: boolean;\r\n    protected _ctrlKey: boolean;\r\n    protected _metaKey: boolean;\r\n    protected _shiftKey: boolean;\r\n\r\n    /**\r\n     * Which mouse buttons were pressed at time of last mouse event.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n     */\r\n    protected _buttonsPressed: number;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _contextMenuBind: EventListener;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n        let previousPinchSquaredDistance = 0;\r\n        let previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\r\n\r\n        this._pointA = null;\r\n        this._pointB = null;\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n\r\n        this._pointerInput = (p) => {\r\n            const evt = <IPointerEvent>p.event;\r\n            const isTouch = evt.pointerType === \"touch\";\r\n\r\n            if (engine.isInVRExclusivePointerMode) {\r\n                return;\r\n            }\r\n\r\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n\r\n            const srcElement = <HTMLElement>evt.target;\r\n\r\n            this._altKey = evt.altKey;\r\n            this._ctrlKey = evt.ctrlKey;\r\n            this._metaKey = evt.metaKey;\r\n            this._shiftKey = evt.shiftKey;\r\n            this._buttonsPressed = evt.buttons;\r\n\r\n            if (engine.isPointerLock) {\r\n                const offsetX = evt.movementX;\r\n                const offsetY = evt.movementY;\r\n\r\n                this.onTouch(null, offsetX, offsetY);\r\n                this._pointA = null;\r\n                this._pointB = null;\r\n            } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\r\n                try {\r\n                    srcElement?.setPointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n\r\n                if (this._pointA === null) {\r\n                    this._pointA = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else if (this._pointB === null) {\r\n                    this._pointB = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                }\r\n\r\n                if (this._currentActiveButton === -1 && !isTouch) {\r\n                    this._currentActiveButton = evt.button;\r\n                }\r\n                this.onButtonDown(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    element && element.focus();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                this.onDoubleTap(evt.pointerType);\r\n            } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\r\n                try {\r\n                    srcElement?.releasePointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n\r\n                if (!isTouch) {\r\n                    this._pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    this._pointA = this._pointB = null;\r\n                } else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\r\n                        this._pointA = this._pointB;\r\n                        this._pointB = null;\r\n                    } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\r\n                        this._pointB = null;\r\n                    } else {\r\n                        this._pointA = this._pointB = null;\r\n                    }\r\n                }\r\n\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    this.onMultiTouch(\r\n                        this._pointA,\r\n                        this._pointB,\r\n                        previousPinchSquaredDistance,\r\n                        0, // pinchSquaredDistance\r\n                        previousMultiTouchPanPosition,\r\n                        null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n\r\n                this._currentActiveButton = -1;\r\n                this.onButtonUp(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                // One button down\r\n                if (this._pointA && this._pointB === null) {\r\n                    const offsetX = evt.clientX - this._pointA.x;\r\n                    const offsetY = evt.clientY - this._pointA.y;\r\n                    this.onTouch(this._pointA, offsetX, offsetY);\r\n\r\n                    this._pointA.x = evt.clientX;\r\n                    this._pointA.y = evt.clientY;\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (this._pointA && this._pointB) {\r\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    const distX = this._pointA.x - this._pointB.x;\r\n                    const distY = this._pointA.y - this._pointB.y;\r\n                    const pinchSquaredDistance = distX * distX + distY * distY;\r\n                    const multiTouchPanPosition = {\r\n                        x: (this._pointA.x + this._pointB.x) / 2,\r\n                        y: (this._pointA.y + this._pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type,\r\n                    };\r\n\r\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            .onPointerObservable.add(\r\n                this._pointerInput,\r\n                PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP\r\n            );\r\n\r\n        this._onLostFocus = () => {\r\n            this._pointA = this._pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            this.onLostFocus();\r\n        };\r\n\r\n        this._contextMenuBind = this.onContextMenu.bind(this);\r\n\r\n        element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._onLostFocus) {\r\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n            }\r\n        }\r\n\r\n        if (this._observer) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n            this._observer = null;\r\n\r\n            if (this._contextMenuBind) {\r\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            this._onLostFocus = null;\r\n        }\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"pointers\";\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     * @param type\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onDoubleTap(type: string) {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     * @param point\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA\r\n     * @param _pointB\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {}\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onButtonDown(evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onButtonUp(evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    public onLostFocus(): void {}\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _pointA: Nullable<PointerTouch>;\r\n    private _pointB: Nullable<PointerTouch>;\r\n}\r\n","import type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FollowCamera } from \"../../Cameras/followCamera\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Manage the keyboard inputs to control the movement of a follow camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FollowCameraKeyboardMoveInput implements ICameraInput<FollowCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FollowCamera;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the up action (increase heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetIncr = [38];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the down action (decrease heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetDecr = [40];\r\n\r\n    /**\r\n     * Defines whether the Alt modifier key is required to move up/down (alter heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetModifierAlt: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Ctrl modifier key is required to move up/down (alter heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetModifierCtrl: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Shift modifier key is required to move up/down (alter heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetModifierShift: boolean = false;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the left action (increase rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetIncr = [37];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the right action (decrease rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetDecr = [39];\r\n\r\n    /**\r\n     * Defines whether the Alt modifier key is required to move left/right (alter rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetModifierAlt: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Ctrl modifier key is required to move left/right (alter rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetModifierCtrl: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Shift modifier key is required to move left/right (alter rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetModifierShift: boolean = false;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the zoom-in action (decrease radius)\r\n     */\r\n    @serialize()\r\n    public keysRadiusIncr = [40];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the zoom-out action (increase radius)\r\n     */\r\n    @serialize()\r\n    public keysRadiusDecr = [38];\r\n\r\n    /**\r\n     * Defines whether the Alt modifier key is required to zoom in/out (alter radius value)\r\n     */\r\n    @serialize()\r\n    public keysRadiusModifierAlt: boolean = true;\r\n\r\n    /**\r\n     * Defines whether the Ctrl modifier key is required to zoom in/out (alter radius value)\r\n     */\r\n    @serialize()\r\n    public keysRadiusModifierCtrl: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Shift modifier key is required to zoom in/out (alter radius value)\r\n     */\r\n    @serialize()\r\n    public keysRadiusModifierShift: boolean = false;\r\n\r\n    /**\r\n     * Defines the rate of change of heightOffset.\r\n     */\r\n    @serialize()\r\n    public heightSensibility: number = 1;\r\n\r\n    /**\r\n     * Defines the rate of change of rotationOffset.\r\n     */\r\n    @serialize()\r\n    public rotationSensibility: number = 1;\r\n\r\n    /**\r\n     * Defines the rate of change of radius.\r\n     */\r\n    @serialize()\r\n    public radiusSensibility: number = 1;\r\n\r\n    private _keys = new Array<number>();\r\n    private _ctrlPressed: boolean;\r\n    private _altPressed: boolean;\r\n    private _shiftPressed: boolean;\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    this._ctrlPressed = evt.ctrlKey;\r\n                    this._altPressed = evt.altKey;\r\n                    this._shiftPressed = evt.shiftKey;\r\n\r\n                    if (\r\n                        this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusDecr.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusDecr.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            this._keys.forEach((keyCode) => {\r\n                if (this.keysHeightOffsetIncr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {\r\n                    this.camera.heightOffset += this.heightSensibility;\r\n                } else if (this.keysHeightOffsetDecr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {\r\n                    this.camera.heightOffset -= this.heightSensibility;\r\n                } else if (this.keysRotationOffsetIncr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {\r\n                    this.camera.rotationOffset += this.rotationSensibility;\r\n                    this.camera.rotationOffset %= 360;\r\n                } else if (this.keysRotationOffsetDecr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {\r\n                    this.camera.rotationOffset -= this.rotationSensibility;\r\n                    this.camera.rotationOffset %= 360;\r\n                } else if (this.keysRadiusIncr.indexOf(keyCode) !== -1 && this._modifierRadius()) {\r\n                    this.camera.radius += this.radiusSensibility;\r\n                } else if (this.keysRadiusDecr.indexOf(keyCode) !== -1 && this._modifierRadius()) {\r\n                    this.camera.radius -= this.radiusSensibility;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    /**\r\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\r\n     * allow modification of the heightOffset value.\r\n     */\r\n    private _modifierHeightOffset(): boolean {\r\n        return (\r\n            this.keysHeightOffsetModifierAlt === this._altPressed &&\r\n            this.keysHeightOffsetModifierCtrl === this._ctrlPressed &&\r\n            this.keysHeightOffsetModifierShift === this._shiftPressed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\r\n     * allow modification of the rotationOffset value.\r\n     */\r\n    private _modifierRotationOffset(): boolean {\r\n        return (\r\n            this.keysRotationOffsetModifierAlt === this._altPressed &&\r\n            this.keysRotationOffsetModifierCtrl === this._ctrlPressed &&\r\n            this.keysRotationOffsetModifierShift === this._shiftPressed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\r\n     * allow modification of the radius value.\r\n     */\r\n    private _modifierRadius(): boolean {\r\n        return this.keysRadiusModifierAlt === this._altPressed && this.keysRadiusModifierCtrl === this._ctrlPressed && this.keysRadiusModifierShift === this._shiftPressed;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FollowCameraKeyboardMoveInput\"] = FollowCameraKeyboardMoveInput;\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { FollowCamera } from \"../../Cameras/followCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a follow camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FollowCameraMouseWheelInput implements ICameraInput<FollowCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FollowCamera;\r\n\r\n    /**\r\n     * Moue wheel controls zoom. (Mouse wheel modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisControlRadius: boolean = true;\r\n\r\n    /**\r\n     * Moue wheel controls height. (Mouse wheel modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisControlHeight: boolean = false;\r\n\r\n    /**\r\n     * Moue wheel controls angle. (Mouse wheel modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisControlRotation: boolean = false;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera moves in\r\n     * relation to mouseWheel events.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n\r\n            const wheelDelta = Math.max(-1, Math.min(1, event.deltaY));\r\n            if (this.wheelDeltaPercentage) {\r\n                console.assert(\r\n                    <number>(<unknown>this.axisControlRadius) + <number>(<unknown>this.axisControlHeight) + <number>(<unknown>this.axisControlRotation) <= 1,\r\n                    \"wheelDeltaPercentage only usable when mouse wheel \" +\r\n                        \"controls ONE axis. \" +\r\n                        \"Currently enabled: \" +\r\n                        \"axisControlRadius: \" +\r\n                        this.axisControlRadius +\r\n                        \", axisControlHeightOffset: \" +\r\n                        this.axisControlHeight +\r\n                        \", axisControlRotationOffset: \" +\r\n                        this.axisControlRotation\r\n                );\r\n\r\n                if (this.axisControlRadius) {\r\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.radius;\r\n                } else if (this.axisControlHeight) {\r\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.heightOffset;\r\n                } else if (this.axisControlRotation) {\r\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.rotationOffset;\r\n                }\r\n            } else {\r\n                delta = wheelDelta * this.wheelPrecision;\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.axisControlRadius) {\r\n                    this.camera.radius += delta;\r\n                } else if (this.axisControlHeight) {\r\n                    this.camera.heightOffset -= delta;\r\n                } else if (this.axisControlRotation) {\r\n                    this.camera.rotationOffset -= delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FollowCameraMouseWheelInput\"] = FollowCameraMouseWheelInput;\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FollowCamera } from \"../../Cameras/followCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an follow camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FollowCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FollowCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the X axis or how fast is\r\n     * the camera rotating.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 10000.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * Pointer X axis controls zoom. (X axis modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlRadius: boolean = false;\r\n\r\n    /**\r\n     * Pointer X axis controls height. (X axis modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlHeight: boolean = false;\r\n\r\n    /**\r\n     * Pointer X axis controls angle. (X axis modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlRotation: boolean = true;\r\n\r\n    /**\r\n     * Pointer Y axis controls zoom. (Y axis modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlRadius: boolean = false;\r\n\r\n    /**\r\n     * Pointer Y axis controls height. (Y axis modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlHeight: boolean = true;\r\n\r\n    /**\r\n     * Pointer Y axis controls angle. (Y axis modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlRotation: boolean = false;\r\n\r\n    /**\r\n     * Pinch controls zoom. (Pinch modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlRadius: boolean = true;\r\n\r\n    /**\r\n     * Pinch controls height. (Pinch modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlHeight: boolean = false;\r\n\r\n    /**\r\n     * Pinch controls angle. (Pinch modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlRotation: boolean = false;\r\n\r\n    /**\r\n     * Log error messages if basic misconfiguration has occurred.\r\n     */\r\n    public warningEnable: boolean = true;\r\n\r\n    public onTouch(pointA: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        this._warning();\r\n\r\n        if (this.axisXControlRotation) {\r\n            this.camera.rotationOffset += offsetX / this.angularSensibilityX;\r\n        } else if (this.axisYControlRotation) {\r\n            this.camera.rotationOffset += offsetY / this.angularSensibilityX;\r\n        }\r\n\r\n        if (this.axisXControlHeight) {\r\n            this.camera.heightOffset += offsetX / this.angularSensibilityY;\r\n        } else if (this.axisYControlHeight) {\r\n            this.camera.heightOffset += offsetY / this.angularSensibilityY;\r\n        }\r\n\r\n        if (this.axisXControlRadius) {\r\n            this.camera.radius -= offsetX / this.angularSensibilityY;\r\n        } else if (this.axisYControlRadius) {\r\n            this.camera.radius -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    public onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n        let pinchDelta = (pinchSquaredDistance - previousPinchSquaredDistance) / ((this.pinchPrecision * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n\r\n        if (this.pinchDeltaPercentage) {\r\n            pinchDelta *= 0.01 * this.pinchDeltaPercentage;\r\n            if (this.axisPinchControlRotation) {\r\n                this.camera.rotationOffset += pinchDelta * this.camera.rotationOffset;\r\n            }\r\n            if (this.axisPinchControlHeight) {\r\n                this.camera.heightOffset += pinchDelta * this.camera.heightOffset;\r\n            }\r\n            if (this.axisPinchControlRadius) {\r\n                this.camera.radius -= pinchDelta * this.camera.radius;\r\n            }\r\n        } else {\r\n            if (this.axisPinchControlRotation) {\r\n                this.camera.rotationOffset += pinchDelta;\r\n            }\r\n\r\n            if (this.axisPinchControlHeight) {\r\n                this.camera.heightOffset += pinchDelta;\r\n            }\r\n\r\n            if (this.axisPinchControlRadius) {\r\n                this.camera.radius -= pinchDelta;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Check for obvious misconfiguration. */\r\n    private _warningCounter: number = 0;\r\n    private _warning(): void {\r\n        if (!this.warningEnable || this._warningCounter++ % 100 !== 0) {\r\n            return;\r\n        }\r\n        const warn =\r\n            \"It probably only makes sense to control ONE camera \" + \"property with each pointer axis. Set 'warningEnable = false' \" + \"if you are sure. Currently enabled: \";\r\n\r\n        console.assert(\r\n            <number>(<unknown>this.axisXControlRotation) + <number>(<unknown>this.axisXControlHeight) + <number>(<unknown>this.axisXControlRadius) <= 1,\r\n            warn + \"axisXControlRotation: \" + this.axisXControlRotation + \", axisXControlHeight: \" + this.axisXControlHeight + \", axisXControlRadius: \" + this.axisXControlRadius\r\n        );\r\n        console.assert(\r\n            <number>(<unknown>this.axisYControlRotation) + <number>(<unknown>this.axisYControlHeight) + <number>(<unknown>this.axisYControlRadius) <= 1,\r\n            warn + \"axisYControlRotation: \" + this.axisYControlRotation + \", axisYControlHeight: \" + this.axisYControlHeight + \", axisYControlRadius: \" + this.axisYControlRadius\r\n        );\r\n        console.assert(\r\n            <number>(<unknown>this.axisPinchControlRotation) + <number>(<unknown>this.axisPinchControlHeight) + <number>(<unknown>this.axisPinchControlRadius) <= 1,\r\n            warn +\r\n                \"axisPinchControlRotation: \" +\r\n                this.axisPinchControlRotation +\r\n                \", axisPinchControlHeight: \" +\r\n                this.axisPinchControlHeight +\r\n                \", axisPinchControlRadius: \" +\r\n                this.axisPinchControlRadius\r\n        );\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"FollowCameraPointersInput\"] = FollowCameraPointersInput;\r\n","import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<TCamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<TCamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\nexport interface CameraInputsMap<TCamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<TCamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<TCamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class CameraInputsManager<TCamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<TCamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: TCamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: TCamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n     * @param input camera input method\r\n     */\r\n    public add(input: ICameraInput<TCamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        //for checkInputs, we are dynamically creating a function\r\n        //the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<TCamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<TCamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport { serialize, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { FollowCameraInputsManager } from \"./followCameraInputsManager\";\r\nNode.AddNodeConstructor(\"FollowCamera\", (name, scene) => {\r\n    return () => new FollowCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\nNode.AddNodeConstructor(\"ArcFollowCamera\", (name, scene) => {\r\n    return () => new ArcFollowCamera(name, 0, 0, 1.0, null, scene);\r\n});\r\n\r\n/**\r\n * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\r\n * an arc rotate version arcFollowCamera are available.\r\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n */\r\nexport class FollowCamera extends TargetCamera {\r\n    /**\r\n     * Distance the follow camera should follow an object at\r\n     */\r\n    @serialize()\r\n    public radius: number = 12;\r\n\r\n    /**\r\n     * Minimum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define a rotation offset between the camera and the object it follows\r\n     */\r\n    @serialize()\r\n    public rotationOffset: number = 0;\r\n\r\n    /**\r\n     * Minimum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRotationOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRotationOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define a height offset between the camera and the object it follows.\r\n     * It can help following an object from the top (like a car chasing a plane)\r\n     */\r\n    @serialize()\r\n    public heightOffset: number = 4;\r\n\r\n    /**\r\n     * Minimum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerHeightOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperHeightOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define how fast the camera can accelerate to follow it s target.\r\n     */\r\n    @serialize()\r\n    public cameraAcceleration: number = 0.05;\r\n\r\n    /**\r\n     * Define the speed limit of the camera following an object.\r\n     */\r\n    @serialize()\r\n    public maxCameraSpeed: number = 20;\r\n\r\n    /**\r\n     * Define the target of the camera.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Defines the input associated with the camera.\r\n     */\r\n    public inputs: FollowCameraInputsManager;\r\n\r\n    /**\r\n     * Instantiates the follow camera.\r\n     * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the position of the camera\r\n     * @param scene Define the scene the camera belong to\r\n     * @param lockedTarget Define the target of the camera\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, lockedTarget: Nullable<AbstractMesh> = null) {\r\n        super(name, position, scene);\r\n\r\n        this.lockedTarget = lockedTarget;\r\n        this.inputs = new FollowCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\r\n        // Uncomment the following line when the relevant handlers have been implemented.\r\n        // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();\r\n    }\r\n\r\n    private _follow(cameraTarget: AbstractMesh) {\r\n        if (!cameraTarget) {\r\n            return;\r\n        }\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        cameraTarget.absoluteRotationQuaternion.toRotationMatrix(rotMatrix);\r\n        const yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\r\n\r\n        const radians = Tools.ToRadians(this.rotationOffset) + yRotation;\r\n        const targetPosition = cameraTarget.getAbsolutePosition();\r\n        const targetX: number = targetPosition.x + Math.sin(radians) * this.radius;\r\n\r\n        const targetZ: number = targetPosition.z + Math.cos(radians) * this.radius;\r\n        const dx: number = targetX - this.position.x;\r\n        const dy: number = targetPosition.y + this.heightOffset - this.position.y;\r\n        const dz: number = targetZ - this.position.z;\r\n        let vx: number = dx * this.cameraAcceleration * 2; //this is set to .05\r\n        let vy: number = dy * this.cameraAcceleration;\r\n        let vz: number = dz * this.cameraAcceleration * 2;\r\n\r\n        if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\r\n            vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\r\n            vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\r\n            vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\r\n        this.setTarget(targetPosition);\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n\r\n        this._reset = () => {};\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        if (this._reset) {\r\n            this._reset();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        this.inputs.checkInputs();\r\n        this._checkLimits();\r\n        super._checkInputs();\r\n        if (this.lockedTarget) {\r\n            this._follow(this.lockedTarget);\r\n        }\r\n    }\r\n\r\n    private _checkLimits() {\r\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\r\n            this.radius = this.lowerRadiusLimit;\r\n        }\r\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\r\n            this.radius = this.upperRadiusLimit;\r\n        }\r\n\r\n        if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {\r\n            this.heightOffset = this.lowerHeightOffsetLimit;\r\n        }\r\n        if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {\r\n            this.heightOffset = this.upperHeightOffsetLimit;\r\n        }\r\n\r\n        if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {\r\n            this.rotationOffset = this.lowerRotationOffsetLimit;\r\n        }\r\n        if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {\r\n            this.rotationOffset = this.upperRotationOffsetLimit;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the camera class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCamera\";\r\n    }\r\n}\r\n\r\n/**\r\n * Arc Rotate version of the follow camera.\r\n * It still follows a Defined mesh but in an Arc Rotate Camera fashion.\r\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n */\r\nexport class ArcFollowCamera extends TargetCamera {\r\n    private _cartesianCoordinates: Vector3 = Vector3.Zero();\r\n\r\n    /** Define the camera target (the mesh it should follow) */\r\n    private _meshTarget: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Instantiates a new ArcFollowCamera\r\n     * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n     * @param name Define the name of the camera\r\n     * @param alpha Define the rotation angle of the camera around the longitudinal axis\r\n     * @param beta Define the rotation angle of the camera around the elevation axis\r\n     * @param radius Define the radius of the camera from its target point\r\n     * @param target Define the target of the camera\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(\r\n        name: string,\r\n        /** The longitudinal angle of the camera */\r\n        public alpha: number,\r\n        /** The latitudinal angle of the camera */\r\n        public beta: number,\r\n        /** The radius of the camera from its target */\r\n        public radius: number,\r\n        /** Define the camera target (the mesh it should follow) */\r\n        target: Nullable<AbstractMesh>,\r\n        scene: Scene\r\n    ) {\r\n        super(name, Vector3.Zero(), scene);\r\n        this.setMeshTarget(target);\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh to follow with this camera.\r\n     * @param target the target to follow\r\n     */\r\n    public setMeshTarget(target: Nullable<AbstractMesh>) {\r\n        this._meshTarget = target;\r\n        this._follow();\r\n    }\r\n\r\n    private _follow(): void {\r\n        if (!this._meshTarget) {\r\n            return;\r\n        }\r\n        this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\r\n        this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\r\n        this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\r\n\r\n        const targetPosition = this._meshTarget.getAbsolutePosition();\r\n        this.position = targetPosition.add(this._cartesianCoordinates);\r\n        this.setTarget(targetPosition);\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        super._checkInputs();\r\n        this._follow();\r\n    }\r\n\r\n    /**\r\n     * Returns the class name of the object.\r\n     * It is mostly used internally for serialization purposes.\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcFollowCamera\";\r\n    }\r\n}\r\n","import { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport type { FollowCamera } from \"./followCamera\";\r\nimport { FollowCameraKeyboardMoveInput } from \"./Inputs/followCameraKeyboardMoveInput\";\r\nimport { FollowCameraMouseWheelInput } from \"./Inputs/followCameraMouseWheelInput\";\r\nimport { FollowCameraPointersInput } from \"./Inputs/followCameraPointersInput\";\r\n\r\n/**\r\n * Default Inputs manager for the FollowCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FollowCameraInputsManager extends CameraInputsManager<FollowCamera> {\r\n    /**\r\n     * Instantiates a new FollowCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FollowCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addKeyboard(): FollowCameraInputsManager {\r\n        this.add(new FollowCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addMouseWheel(): FollowCameraInputsManager {\r\n        this.add(new FollowCameraMouseWheelInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addPointers(): FollowCameraInputsManager {\r\n        this.add(new FollowCameraPointersInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add orientation input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addVRDeviceOrientation(): FollowCameraInputsManager {\r\n        console.warn(\"DeviceOrientation support not yet implemented for FollowCamera.\");\r\n        return this;\r\n    }\r\n}\r\n","import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @internal */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialFocalDistance = 1;\r\n    /** @internal */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @internal */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const direction = this.getTarget().subtract(this.position);\r\n        direction.normalize();\r\n        direction.scaleInPlace(distance);\r\n        return this.globalPosition.add(direction);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            this.lockedTarget.computeWorldMatrix();\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        const vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\r\n        } else {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this.position.addInPlace(TmpVectors.Vector3[0]);\r\n            return;\r\n        }\r\n        this.position.addInPlace(this.cameraDirection);\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\r\n            }\r\n\r\n            this.rotation.x += this.cameraRotation.x * directionMultiplier;\r\n            this.rotation.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this.rotation.x > limit) {\r\n                    this.rotation.x = limit;\r\n                }\r\n                if (this.rotation.x < -limit) {\r\n                    this.rotation.x = -limit;\r\n                }\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this.rotation.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n"],"names":["BaseCameraPointersInput","_currentActiveButton","buttons","attachControl","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","engine","this","camera","getEngine","element","getInputElement","previousPinchSquaredDistance","previousMultiTouchPanPosition","_pointA","_pointB","_altKey","_ctrlKey","_metaKey","_shiftKey","_buttonsPressed","_pointerInput","p","evt","event","isTouch","pointerType","isInVRExclusivePointerMode","type","POINTERMOVE","indexOf","button","srcElement","target","altKey","ctrlKey","metaKey","shiftKey","isPointerLock","offsetX","movementX","offsetY","movementY","onTouch","POINTERDOWN","POINTERDOUBLETAP","onDoubleTap","POINTERUP","preventDefault","clientX","x","clientY","y","ed","pointerId","distX","distY","pinchSquaredDistance","multiTouchPanPosition","onMultiTouch","releasePointerCapture","e","_badOS","onButtonUp","setPointerCapture","onButtonDown","focus","_observer","getScene","onPointerObservable","add","_onLostFocus","onLostFocus","_contextMenuBind","onContextMenu","bind","addEventListener","hostWindow","getHostWindow","RegisterTopRootEvents","name","handler","detachControl","UnregisterTopRootEvents","remove","inputElement","removeEventListener","getClassName","getSimpleName","point","FollowCameraKeyboardMoveInput","keysHeightOffsetIncr","keysHeightOffsetDecr","keysHeightOffsetModifierAlt","keysHeightOffsetModifierCtrl","keysHeightOffsetModifierShift","keysRotationOffsetIncr","keysRotationOffsetDecr","keysRotationOffsetModifierAlt","keysRotationOffsetModifierCtrl","keysRotationOffsetModifierShift","keysRadiusIncr","keysRadiusDecr","keysRadiusModifierAlt","keysRadiusModifierCtrl","keysRadiusModifierShift","heightSensibility","rotationSensibility","radiusSensibility","_keys","Array","_onCanvasBlurObserver","_scene","_engine","onCanvasBlurObservable","length","_onKeyboardObserver","onKeyboardObservable","info","KEYDOWN","_ctrlPressed","_altPressed","_shiftPressed","keyCode","push","index","splice","checkInputs","forEach","_modifierHeightOffset","heightOffset","_modifierRotationOffset","rotationOffset","_modifierRadius","radius","FollowCameraMouseWheelInput","axisControlRadius","axisControlHeight","axisControlRotation","wheelPrecision","wheelDeltaPercentage","_wheel","POINTERWHEEL","delta","wheelDelta","Math","max","min","deltaY","console","assert","FollowCameraPointersInput","angularSensibilityX","angularSensibilityY","pinchPrecision","pinchDeltaPercentage","axisXControlRadius","axisXControlHeight","axisXControlRotation","axisYControlRadius","axisYControlHeight","axisYControlRotation","axisPinchControlRadius","axisPinchControlHeight","axisPinchControlRotation","warningEnable","_warningCounter","pointA","_warning","pointB","pinchDelta","warn","CameraInputTypes","CameraInputsManager","constructor","attachedToElement","attached","input","Warn","_addCheckInputs","inputToRemove","cam","rebuildInputCheck","removeByType","inputType","fn","current","attachInput","attachElement","ForceAttachControlToAlwaysPreventDefault","detachElement","disconnect","clear","serialize","serializedCamera","inputs","res","Serialize","inputsmgr","parse","parsedCamera","parsedInputs","n","construct","parsedinput","Parse","AddNodeConstructor","scene","FollowCamera","Zero","ArcFollowCamera","position","lockedTarget","super","lowerRadiusLimit","upperRadiusLimit","lowerRotationOffsetLimit","upperRotationOffsetLimit","lowerHeightOffsetLimit","upperHeightOffsetLimit","cameraAcceleration","maxCameraSpeed","addKeyboard","addMouseWheel","addPointers","_follow","cameraTarget","rotMatrix","Matrix","absoluteRotationQuaternion","toRotationMatrix","yRotation","atan2","m","radians","ToRadians","targetPosition","getAbsolutePosition","targetX","sin","targetZ","z","cos","dx","dy","dz","vx","vy","vz","setTarget","ignored","_reset","_checkInputs","_checkLimits","alpha","beta","_cartesianCoordinates","setMeshTarget","_meshTarget","FollowCameraInputsManager","F","addVRDeviceOrientation","TargetCamera","setActiveOnSceneIfNoneActive","_tmpUpVector","_tmpTargetVector","cameraDirection","cameraRotation","ignoreParentScaling","updateUpVectorFromRotation","_tmpQuaternion","rotation","speed","noRotationConstraint","invertRotation","inverseRotationSpeed","_currentTarget","_initialFocalDistance","_viewMatrix","_camMatrix","_cameraTransformMatrix","_cameraRotationMatrix","_referencePoint","_transformedReferencePoint","_defaultUp","Up","_cachedRotationZ","_cachedQuaternionRotationZ","getFrontPosition","distance","getWorldMatrix","direction","getTarget","subtract","normalize","scaleInPlace","globalPosition","_getLockedTargetPosition","absolutePosition","computeWorldMatrix","storeState","_storedPosition","clone","_storedRotation","rotationQuaternion","_storedRotationQuaternion","_restoreStateValues","copyFromFloats","_initCache","_cache","Number","MAX_VALUE","_updateCache","ignoreParentClass","lockedTargetPosition","copyFrom","_isSynchronizedViewMatrix","equals","_computeLocalCameraSpeed","sqrt","getDeltaTime","getFps","upVector","LookAtLHToRef","invert","atan","vDir","PI","isNaN","RotationYawPitchRollToRef","value","_decideIfNeedsToMove","abs","_updatePosition","parent","invertToRef","TransformNormalToRef","Vector3","addInPlace","directionMultiplier","needToMove","needToRotate","toEulerAnglesToRef","limit","lengthSquared","inertia","_updateCameraRotationMatrix","_rotateUpVectorWithCameraRotationMatrix","_getViewMatrix","TransformCoordinatesToRef","addToRef","Y","rotateByQuaternionToRef","FromEulerVectorToRef","_computeViewMatrix","up","parentWorldMatrix","_globalPosition","_markSyncedWithParent","useRightHandedSystem","LookAtRHToRef","multiplyToRef","getTranslationToRef","createRigCamera","cameraIndex","cameraRigMode","RIG_MODE_NONE","rigCamera","isRigCamera","rigParent","RIG_MODE_VR","RIG_MODE_WEBVR","_cameraRigParams","mode","orthoLeft","orthoRight","orthoTop","orthoBottom","_updateRigCameras","camLeft","_rigCameras","camRight","RIG_MODE_STEREOSCOPIC_ANAGLYPH","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED","RIG_MODE_STEREOSCOPIC_OVERUNDER","RIG_MODE_STEREOSCOPIC_INTERLACED","leftSign","rightSign","_getRigCamPositionAndTarget","stereoHalfAngle","halfSpace","subtractToRef","_TargetFocalPoint","newFocalTarget","TranslationToRef","_TargetTransformMatrix","RotationAxis","_RigCamTransformMatrix"],"sourceRoot":""}